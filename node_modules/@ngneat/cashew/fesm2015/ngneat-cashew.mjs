import { HttpResponse, HttpContextToken, HttpContext, HTTP_INTERCEPTORS } from '@angular/common/http';
import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Inject, PLATFORM_ID, NgModule } from '@angular/core';
import { EMPTY, of } from 'rxjs';
import { tap, share } from 'rxjs/operators';
import { __rest } from 'tslib';
import { isPlatformServer } from '@angular/common';

class KeySerializer {
}
class DefaultKeySerializer extends KeySerializer {
    serialize(request, context) {
        const { key } = context;
        if (key) {
            return typeof key === 'function' ? key(request) : key;
        }
        return request.urlWithParams;
    }
}

const defaultConfig = {
    strategy: 'explicit',
    mode: 'cache',
    ttl: 3600000 // One hour
};
const HTTP_CACHE_CONFIG = new InjectionToken('HTTP_CACHE_CONFIG');

class CacheBucket extends Set {
}

class RequestsQueue extends Map {
}
RequestsQueue.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: RequestsQueue, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
RequestsQueue.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: RequestsQueue });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: RequestsQueue, decorators: [{
            type: Injectable
        }] });

class HttpCacheStorage extends Map {
}
class DefaultHttpCacheStorage extends HttpCacheStorage {
}
DefaultHttpCacheStorage.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: DefaultHttpCacheStorage, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
DefaultHttpCacheStorage.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: DefaultHttpCacheStorage });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: DefaultHttpCacheStorage, decorators: [{
            type: Injectable
        }] });

class HttpCacheGuard {
}
class DefaultHttpCacheGuard {
    canActivate(request) {
        return request.method === 'GET' && request.responseType === 'json';
    }
}

class TTLManager extends Map {
}
class DefaultTTLManager extends TTLManager {
    constructor(config) {
        super();
        this.config = config;
    }
    isValid(key) {
        return this.get(key) > new Date().getTime();
    }
    set(key, ttl) {
        return super.set(key, new Date().setMilliseconds(ttl || this.config.ttl));
    }
}
DefaultTTLManager.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: DefaultTTLManager, deps: [{ token: HTTP_CACHE_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });
DefaultTTLManager.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: DefaultTTLManager });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: DefaultTTLManager, decorators: [{
            type: Injectable
        }], ctorParameters: function () {
        return [{ type: undefined, decorators: [{
                        type: Inject,
                        args: [HTTP_CACHE_CONFIG]
                    }] }];
    } });

class RequestsCache extends Map {
}
RequestsCache.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: RequestsCache, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
RequestsCache.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: RequestsCache });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: RequestsCache, decorators: [{
            type: Injectable
        }] });

class HttpCacheVersions extends Map {
}
class DefaultHttpVersions extends HttpCacheVersions {
}
DefaultHttpVersions.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: DefaultHttpVersions, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
DefaultHttpVersions.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: DefaultHttpVersions });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: DefaultHttpVersions, decorators: [{
            type: Injectable
        }] });

class HttpCacheManager {
    constructor(queue, storage, guard, ttlManager, requests, version, config) {
        this.queue = queue;
        this.storage = storage;
        this.guard = guard;
        this.ttlManager = ttlManager;
        this.requests = requests;
        this.version = version;
        this.config = config;
    }
    validate(key) {
        const has = this.storage.has(key);
        const isValid = this.ttlManager.isValid(key);
        if (has && isValid)
            return true;
        this.storage.delete(key);
        return false;
    }
    get(key) {
        return this._resolveResponse(this.storage.get(key));
    }
    has(key) {
        return this.storage.has(key);
    }
    set(key, body, { ttl, bucket } = {}) {
        let response = body;
        if (!(body instanceof HttpResponse)) {
            response = new HttpResponse({
                body,
                status: 200,
                url: key
            });
        }
        this._set(key, response, ttl);
        bucket && bucket.add(key);
    }
    delete(key, { deleteRequests, deleteVersions } = {}) {
        if (key instanceof CacheBucket) {
            key.forEach(value => this.delete(value));
            key.clear();
            return;
        }
        this.storage.delete(key);
        this.ttlManager.delete(key);
        this.queue.delete(key);
        if (deleteRequests !== false) {
            this._getRequests().delete(key);
        }
        if (deleteVersions !== false) {
            this._getVersions().delete(key);
        }
    }
    clear() {
        this.storage.clear();
        this.ttlManager.clear();
        this.queue.clear();
        this._getVersions().clear();
        this._getRequests().clear();
    }
    _getQueue() {
        return this.queue;
    }
    _getRequests() {
        return this.requests;
    }
    _getVersions() {
        return this.version;
    }
    _isCacheable(canActivate, cache) {
        const strategy = this.config.strategy;
        if (strategy === 'explicit') {
            return cache;
        }
        if (canActivate && strategy === 'implicit') {
            return cache !== false;
        }
        return false;
    }
    _set(key, response, ttl) {
        this.storage.set(key, response);
        this.ttlManager.set(key, ttl);
    }
    _canActivate(request) {
        return this.guard.canActivate(request);
    }
    _resolveResponse(event) {
        return this.config.responseSerializer ? event.clone({ body: this.config.responseSerializer(event.body) }) : event;
    }
}
HttpCacheManager.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: HttpCacheManager, deps: [{ token: RequestsQueue }, { token: HttpCacheStorage }, { token: HttpCacheGuard }, { token: TTLManager }, { token: RequestsCache }, { token: HttpCacheVersions }, { token: HTTP_CACHE_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });
HttpCacheManager.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: HttpCacheManager });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: HttpCacheManager, decorators: [{
            type: Injectable
        }], ctorParameters: function () {
        return [{ type: RequestsQueue }, { type: HttpCacheStorage }, { type: HttpCacheGuard }, { type: TTLManager }, { type: RequestsCache }, { type: HttpCacheVersions }, { type: undefined, decorators: [{
                        type: Inject,
                        args: [HTTP_CACHE_CONFIG]
                    }] }];
    } });

const CACHE_CONTEXT = new HttpContextToken(() => ({}));
function withCache(options = {}) {
    const { context } = options, remainingOptions = __rest(options, ["context"]);
    return (context !== null && context !== void 0 ? context : new HttpContext()).set(CACHE_CONTEXT, Object.assign({ cache: true, returnSource: EMPTY }, remainingOptions));
}

class HttpCacheInterceptor {
    constructor(httpCacheManager, keySerializer, platformId, config) {
        this.httpCacheManager = httpCacheManager;
        this.keySerializer = keySerializer;
        this.platformId = platformId;
        this.config = config;
    }
    intercept(request, next) {
        const context = request.context.get(CACHE_CONTEXT);
        if (isPlatformServer(this.platformId)) {
            return next.handle(request);
        }
        const key = this.keySerializer.serialize(request, context);
        const { cache = this.config.strategy === 'implicit', ttl, bucket, clearCachePredicate, version, mode, returnSource } = context;
        if (version) {
            const versions = this.httpCacheManager._getVersions();
            const currentVersion = versions.get(key);
            if (currentVersion !== version) {
                this.httpCacheManager.delete(key);
            }
            versions.set(key, version);
        }
        if (key && clearCachePredicate) {
            const requests = this.httpCacheManager._getRequests();
            const clearCache = clearCachePredicate(requests.get(key), requests.set(key, request).get(key), key);
            if (clearCache) {
                this.httpCacheManager.delete(key, { deleteRequests: false, deleteVersions: false });
            }
        }
        const canActivate = this.httpCacheManager._canActivate(request);
        if (this.httpCacheManager._isCacheable(canActivate, cache)) {
            const queue = this.httpCacheManager._getQueue();
            bucket && bucket.add(key);
            if (queue.has(key)) {
                return queue.get(key);
            }
            if (this.httpCacheManager.validate(key)) {
                return mode === 'stateManagement' ? returnSource : of(this.httpCacheManager.get(key));
            }
            const shared = next.handle(request).pipe(tap(event => {
                if (event instanceof HttpResponse) {
                    if (mode === 'stateManagement') {
                        this.httpCacheManager._set(key, true, ttl || this.config.ttl);
                    }
                    else {
                        const cache = this.httpCacheManager._resolveResponse(event);
                        this.httpCacheManager._set(key, cache, ttl || this.config.ttl);
                    }
                    queue.delete(key);
                }
            }, err => queue.delete(key)), share());
            queue.set(key, shared);
            return shared;
        }
        return next.handle(request);
    }
}
HttpCacheInterceptor.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: HttpCacheInterceptor, deps: [{ token: HttpCacheManager }, { token: KeySerializer }, { token: PLATFORM_ID }, { token: HTTP_CACHE_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });
HttpCacheInterceptor.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: HttpCacheInterceptor });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: HttpCacheInterceptor, decorators: [{
            type: Injectable
        }], ctorParameters: function () {
        return [{ type: HttpCacheManager }, { type: KeySerializer }, { type: Object, decorators: [{
                        type: Inject,
                        args: [PLATFORM_ID]
                    }] }, { type: undefined, decorators: [{
                        type: Inject,
                        args: [HTTP_CACHE_CONFIG]
                    }] }];
    } });

class HttpCacheInterceptorModule {
    static forRoot(config = {}) {
        return {
            providers: [
                { provide: HTTP_CACHE_CONFIG, useValue: Object.assign(Object.assign({}, defaultConfig), config) },
                { provide: KeySerializer, useClass: DefaultKeySerializer },
                { provide: HttpCacheStorage, useClass: DefaultHttpCacheStorage },
                { provide: TTLManager, useClass: DefaultTTLManager },
                { provide: HttpCacheGuard, useClass: DefaultHttpCacheGuard },
                { provide: HttpCacheVersions, useClass: DefaultHttpVersions },
                config.skipInterceptorDeclaration
                    ? []
                    : { provide: HTTP_INTERCEPTORS, useClass: HttpCacheInterceptor, multi: true },
                HttpCacheManager,
                RequestsQueue,
                RequestsCache
            ],
            ngModule: HttpCacheInterceptorModule
        };
    }
}
HttpCacheInterceptorModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: HttpCacheInterceptorModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
HttpCacheInterceptorModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "14.2.10", ngImport: i0, type: HttpCacheInterceptorModule });
HttpCacheInterceptorModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: HttpCacheInterceptorModule });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: HttpCacheInterceptorModule, decorators: [{
            type: NgModule,
            args: [{}]
        }] });

const storage = {
    clearItem(key) {
        localStorage.removeItem(key);
    },
    setItem(key, value) {
        localStorage.setItem(key, JSON.stringify(value));
    },
    getItem(key) {
        const value = localStorage.getItem(key);
        if (!value) {
            return undefined;
        }
        return JSON.parse(value);
    }
};

const KEY$2 = `@cache`;
function createKey$2(key) {
    return `${KEY$2}-${key}`;
}
class HttpCacheLocalStorage extends HttpCacheStorage {
    has(key) {
        return super.has(createKey$2(key)) || !!storage.getItem(createKey$2(key));
    }
    get(key) {
        const cacheValue = super.get(createKey$2(key));
        if (cacheValue) {
            return cacheValue;
        }
        const value = storage.getItem(createKey$2(key));
        if (value) {
            super.set(createKey$2(key), new HttpResponse(value));
        }
        return super.get(createKey$2(key));
    }
    set(key, response) {
        storage.setItem(createKey$2(key), response);
        return super.set(createKey$2(key), response);
    }
    delete(key) {
        storage.clearItem(createKey$2(key));
        return super.delete(createKey$2(key));
    }
    clear() {
        super.forEach((value, key) => {
            super.delete(key);
            storage.clearItem(key);
        });
    }
}
HttpCacheLocalStorage.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: HttpCacheLocalStorage, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
HttpCacheLocalStorage.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: HttpCacheLocalStorage });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: HttpCacheLocalStorage, decorators: [{
            type: Injectable
        }] });

const KEY$1 = `@ttl`;
function createKey$1(key) {
    return `${KEY$1}-${key}`;
}
class LocalStorageTTLManager extends TTLManager {
    constructor(config) {
        super();
        this.config = config;
        this.ttl = new DefaultTTLManager(config);
    }
    isValid(key) {
        const valid = this.ttl.isValid(createKey$1(key));
        if (valid) {
            return true;
        }
        const localStorageTimeStamp = storage.getItem(createKey$1(key));
        const validInStorage = localStorageTimeStamp > new Date().getTime();
        if (validInStorage) {
            this.ttl.set(createKey$1(key), localStorageTimeStamp - new Date().getTime());
        }
        return validInStorage;
    }
    set(key, ttl) {
        const resolveTTL = ttl !== null && ttl !== void 0 ? ttl : this.config.ttl;
        storage.setItem(createKey$1(key), new Date().setMilliseconds(resolveTTL));
        this.ttl.set(createKey$1(key), resolveTTL);
        return this;
    }
    delete(key) {
        this.ttl.delete(createKey$1(key));
        storage.clearItem(createKey$1(key));
        return true;
    }
    clear() {
        this.ttl.forEach((_, key) => {
            this.ttl.delete(key);
            storage.clearItem(key);
        });
    }
}
LocalStorageTTLManager.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: LocalStorageTTLManager, deps: [{ token: HTTP_CACHE_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });
LocalStorageTTLManager.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: LocalStorageTTLManager });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: LocalStorageTTLManager, decorators: [{
            type: Injectable
        }], ctorParameters: function () {
        return [{ type: undefined, decorators: [{
                        type: Inject,
                        args: [HTTP_CACHE_CONFIG]
                    }] }];
    } });

const KEY = `@version`;
function createKey(key) {
    return `${KEY}-${key}`;
}
class LocalStorageVersionsManager extends HttpCacheVersions {
    has(key) {
        return super.has(createKey(key)) || !!storage.getItem(createKey(key));
    }
    get(key) {
        const cacheValue = super.get(createKey(key));
        if (cacheValue) {
            return cacheValue;
        }
        const value = storage.getItem(createKey(key));
        if (value) {
            super.set(createKey(key), value);
        }
        return super.get(createKey(key));
    }
    set(key, version) {
        storage.setItem(createKey(key), version);
        return super.set(createKey(key), version);
    }
    delete(key) {
        super.delete(key);
        storage.clearItem(key);
        return true;
    }
    clear() {
        super.forEach((_, key) => {
            super.delete(key);
            storage.clearItem(key);
        });
    }
}
LocalStorageVersionsManager.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: LocalStorageVersionsManager, deps: null, target: i0.ɵɵFactoryTarget.Injectable });
LocalStorageVersionsManager.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: LocalStorageVersionsManager });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.2.10", ngImport: i0, type: LocalStorageVersionsManager, decorators: [{
            type: Injectable
        }] });

const useHttpCacheLocalStorage = [
    { provide: HttpCacheStorage, useClass: HttpCacheLocalStorage },
    { provide: TTLManager, useClass: LocalStorageTTLManager },
    { provide: HttpCacheVersions, useClass: LocalStorageVersionsManager }
];

function requestDataChanged(previousRequest, currentRequest) {
    return ((previousRequest === null || previousRequest === void 0 ? void 0 : previousRequest.urlWithParams) !== currentRequest.urlWithParams ||
        JSON.stringify(previousRequest === null || previousRequest === void 0 ? void 0 : previousRequest.body) !== JSON.stringify(currentRequest.body));
}

/**
 * Generated bundle index. Do not edit.
 */

export { CacheBucket, DefaultHttpCacheGuard, DefaultKeySerializer, DefaultTTLManager, HTTP_CACHE_CONFIG, HttpCacheGuard, HttpCacheInterceptor, HttpCacheInterceptorModule, HttpCacheManager, HttpCacheStorage, KeySerializer, TTLManager, requestDataChanged, useHttpCacheLocalStorage, withCache };
//# sourceMappingURL=ngneat-cashew.mjs.map
