(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('ngx-logger'), require('rxjs')) :
    typeof define === 'function' && define.amd ? define('ngx-logger/testing', ['exports', '@angular/core', 'ngx-logger', 'rxjs'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['ngx-logger'] = global['ngx-logger'] || {}, global['ngx-logger'].testing = {}), global.ng.core, global['ngx-logger'], global.rxjs));
}(this, (function (exports, i0, ngxLogger, rxjs) { 'use strict';

    var NGXLoggerConfigEngineMock = /** @class */ (function () {
        function NGXLoggerConfigEngineMock() {
        }
        Object.defineProperty(NGXLoggerConfigEngineMock.prototype, "level", {
            get: function () {
                return ngxLogger.NgxLoggerLevel.ERROR;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NGXLoggerConfigEngineMock.prototype, "serverLogLevel", {
            get: function () {
                return ngxLogger.NgxLoggerLevel.OFF;
            },
            enumerable: false,
            configurable: true
        });
        NGXLoggerConfigEngineMock.prototype.updateConfig = function (config) {
        };
        NGXLoggerConfigEngineMock.prototype.getConfig = function () {
            return { level: ngxLogger.NgxLoggerLevel.ERROR };
        };
        return NGXLoggerConfigEngineMock;
    }());
    /** @nocollapse */ NGXLoggerConfigEngineMock.ɵfac = function NGXLoggerConfigEngineMock_Factory(t) { return new (t || NGXLoggerConfigEngineMock)(); };
    /** @nocollapse */ NGXLoggerConfigEngineMock.ɵprov = i0.ɵɵdefineInjectable({ token: NGXLoggerConfigEngineMock, factory: NGXLoggerConfigEngineMock.ɵfac });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerConfigEngineMock, [{
                type: i0.Injectable
            }], null, null);
    })();

    // todo bmtheo, there should be an interface or something to make sure this mock sticks to the real API
    var NGXLoggerMock = /** @class */ (function () {
        function NGXLoggerMock() {
        }
        Object.defineProperty(NGXLoggerMock.prototype, "level", {
            get: function () {
                return ngxLogger.NgxLoggerLevel.ERROR;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NGXLoggerMock.prototype, "serverLogLevel", {
            get: function () {
                return ngxLogger.NgxLoggerLevel.OFF;
            },
            enumerable: false,
            configurable: true
        });
        NGXLoggerMock.prototype.trace = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
        };
        NGXLoggerMock.prototype.debug = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
        };
        NGXLoggerMock.prototype.info = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
        };
        NGXLoggerMock.prototype.log = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
        };
        NGXLoggerMock.prototype.warn = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
        };
        NGXLoggerMock.prototype.error = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
        };
        NGXLoggerMock.prototype.fatal = function (message) {
            var additional = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                additional[_i - 1] = arguments[_i];
            }
        };
        NGXLoggerMock.prototype.updateConfig = function (config) {
        };
        NGXLoggerMock.prototype.setCustomHttpHeaders = function (headers) {
        };
        NGXLoggerMock.prototype.setCustomParams = function (params) {
        };
        NGXLoggerMock.prototype.registerMonitor = function (monitor) {
        };
        NGXLoggerMock.prototype.setWithCredentialsOptionValue = function (withCredentials) {
        };
        NGXLoggerMock.prototype.getConfigSnapshot = function () {
            return { level: ngxLogger.NgxLoggerLevel.ERROR };
        };
        return NGXLoggerMock;
    }());
    /** @nocollapse */ NGXLoggerMock.ɵfac = function NGXLoggerMock_Factory(t) { return new (t || NGXLoggerMock)(); };
    /** @nocollapse */ NGXLoggerMock.ɵprov = i0.ɵɵdefineInjectable({ token: NGXLoggerMock, factory: NGXLoggerMock.ɵfac });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerMock, [{
                type: i0.Injectable
            }], null, null);
    })();

    /**
     * CustomNGXLoggerServiceMock is a mock for CustomNGXLoggerService
     */
    var CustomNGXLoggerServiceMock = /** @class */ (function () {
        function CustomNGXLoggerServiceMock() {
        }
        CustomNGXLoggerServiceMock.prototype.create = function () {
            return new NGXLoggerMock();
        };
        return CustomNGXLoggerServiceMock;
    }());
    /** @nocollapse */ CustomNGXLoggerServiceMock.ɵfac = function CustomNGXLoggerServiceMock_Factory(t) { return new (t || CustomNGXLoggerServiceMock)(); };
    /** @nocollapse */ CustomNGXLoggerServiceMock.ɵprov = i0.ɵɵdefineInjectable({ token: CustomNGXLoggerServiceMock, factory: CustomNGXLoggerServiceMock.ɵfac });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(CustomNGXLoggerServiceMock, [{
                type: i0.Injectable
            }], null, null);
    })();

    var NGXLoggerConfigEngineFactoryMock = /** @class */ (function () {
        function NGXLoggerConfigEngineFactoryMock() {
        }
        NGXLoggerConfigEngineFactoryMock.prototype.provideConfigEngine = function (config) {
            return new NGXLoggerConfigEngineMock();
        };
        return NGXLoggerConfigEngineFactoryMock;
    }());
    /** @nocollapse */ NGXLoggerConfigEngineFactoryMock.ɵfac = function NGXLoggerConfigEngineFactoryMock_Factory(t) { return new (t || NGXLoggerConfigEngineFactoryMock)(); };
    /** @nocollapse */ NGXLoggerConfigEngineFactoryMock.ɵprov = i0.ɵɵdefineInjectable({ token: NGXLoggerConfigEngineFactoryMock, factory: NGXLoggerConfigEngineFactoryMock.ɵfac });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerConfigEngineFactoryMock, [{
                type: i0.Injectable
            }], null, null);
    })();

    var NGXLoggerMapperServiceMock = /** @class */ (function () {
        function NGXLoggerMapperServiceMock() {
        }
        NGXLoggerMapperServiceMock.prototype.getLogPosition = function (config, metadata) {
            return rxjs.of({ fileName: 'test.ts' });
        };
        return NGXLoggerMapperServiceMock;
    }());
    /** @nocollapse */ NGXLoggerMapperServiceMock.ɵfac = function NGXLoggerMapperServiceMock_Factory(t) { return new (t || NGXLoggerMapperServiceMock)(); };
    /** @nocollapse */ NGXLoggerMapperServiceMock.ɵprov = i0.ɵɵdefineInjectable({ token: NGXLoggerMapperServiceMock, factory: NGXLoggerMapperServiceMock.ɵfac });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerMapperServiceMock, [{
                type: i0.Injectable
            }], null, null);
    })();

    var NGXLoggerMetadataServiceMock = /** @class */ (function () {
        function NGXLoggerMetadataServiceMock() {
        }
        NGXLoggerMetadataServiceMock.prototype.getMetadata = function (level, config, message, additional) {
            return {
                level: level
            };
        };
        return NGXLoggerMetadataServiceMock;
    }());
    /** @nocollapse */ NGXLoggerMetadataServiceMock.ɵfac = function NGXLoggerMetadataServiceMock_Factory(t) { return new (t || NGXLoggerMetadataServiceMock)(); };
    /** @nocollapse */ NGXLoggerMetadataServiceMock.ɵprov = i0.ɵɵdefineInjectable({ token: NGXLoggerMetadataServiceMock, factory: NGXLoggerMetadataServiceMock.ɵfac });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerMetadataServiceMock, [{
                type: i0.Injectable
            }], null, null);
    })();

    var NGXLoggerRulesServiceMock = /** @class */ (function () {
        function NGXLoggerRulesServiceMock() {
        }
        NGXLoggerRulesServiceMock.prototype.shouldCallWriter = function (level, config, message, additional) {
            return false;
        };
        NGXLoggerRulesServiceMock.prototype.shouldCallServer = function (level, config, message, additional) {
            return false;
        };
        NGXLoggerRulesServiceMock.prototype.shouldCallMonitor = function (level, config, message, additional) {
            return false;
        };
        return NGXLoggerRulesServiceMock;
    }());
    /** @nocollapse */ NGXLoggerRulesServiceMock.ɵfac = function NGXLoggerRulesServiceMock_Factory(t) { return new (t || NGXLoggerRulesServiceMock)(); };
    /** @nocollapse */ NGXLoggerRulesServiceMock.ɵprov = i0.ɵɵdefineInjectable({ token: NGXLoggerRulesServiceMock, factory: NGXLoggerRulesServiceMock.ɵfac });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerRulesServiceMock, [{
                type: i0.Injectable
            }], null, null);
    })();

    var NGXLoggerServerServiceMock = /** @class */ (function () {
        function NGXLoggerServerServiceMock() {
        }
        NGXLoggerServerServiceMock.prototype.sendToServer = function (metadata, config) {
        };
        return NGXLoggerServerServiceMock;
    }());
    /** @nocollapse */ NGXLoggerServerServiceMock.ɵfac = function NGXLoggerServerServiceMock_Factory(t) { return new (t || NGXLoggerServerServiceMock)(); };
    /** @nocollapse */ NGXLoggerServerServiceMock.ɵprov = i0.ɵɵdefineInjectable({ token: NGXLoggerServerServiceMock, factory: NGXLoggerServerServiceMock.ɵfac });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerServerServiceMock, [{
                type: i0.Injectable
            }], null, null);
    })();

    var NGXLoggerWriterServiceMock = /** @class */ (function () {
        function NGXLoggerWriterServiceMock() {
        }
        NGXLoggerWriterServiceMock.prototype.writeMessage = function (metadata, config) {
        };
        return NGXLoggerWriterServiceMock;
    }());
    /** @nocollapse */ NGXLoggerWriterServiceMock.ɵfac = function NGXLoggerWriterServiceMock_Factory(t) { return new (t || NGXLoggerWriterServiceMock)(); };
    /** @nocollapse */ NGXLoggerWriterServiceMock.ɵprov = i0.ɵɵdefineInjectable({ token: NGXLoggerWriterServiceMock, factory: NGXLoggerWriterServiceMock.ɵfac });
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerWriterServiceMock, [{
                type: i0.Injectable
            }], null, null);
    })();

    var LoggerTestingModule = /** @class */ (function () {
        function LoggerTestingModule() {
        }
        return LoggerTestingModule;
    }());
    /** @nocollapse */ LoggerTestingModule.ɵfac = function LoggerTestingModule_Factory(t) { return new (t || LoggerTestingModule)(); };
    /** @nocollapse */ LoggerTestingModule.ɵmod = i0.ɵɵdefineNgModule({ type: LoggerTestingModule });
    /** @nocollapse */ LoggerTestingModule.ɵinj = i0.ɵɵdefineInjector({ providers: [
            { provide: ngxLogger.NGXLogger, useClass: NGXLoggerMock },
            { provide: ngxLogger.TOKEN_LOGGER_CONFIG, useValue: { level: ngxLogger.NgxLoggerLevel.ERROR } },
            { provide: ngxLogger.TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, useClass: NGXLoggerConfigEngineFactoryMock },
            { provide: ngxLogger.TOKEN_LOGGER_METADATA_SERVICE, useClass: NGXLoggerMetadataServiceMock },
            { provide: ngxLogger.TOKEN_LOGGER_RULES_SERVICE, useClass: NGXLoggerRulesServiceMock },
            { provide: ngxLogger.TOKEN_LOGGER_MAPPER_SERVICE, useClass: NGXLoggerMapperServiceMock },
            { provide: ngxLogger.TOKEN_LOGGER_WRITER_SERVICE, useClass: NGXLoggerWriterServiceMock },
            { provide: ngxLogger.TOKEN_LOGGER_SERVER_SERVICE, useClass: NGXLoggerServerServiceMock },
            { provide: ngxLogger.CustomNGXLoggerService, useClass: CustomNGXLoggerServiceMock },
        ], imports: [[ngxLogger.LoggerModule]] });
    (function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(LoggerTestingModule, { imports: [ngxLogger.LoggerModule] }); })();
    (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(LoggerTestingModule, [{
                type: i0.NgModule,
                args: [{
                        imports: [ngxLogger.LoggerModule],
                        providers: [
                            { provide: ngxLogger.NGXLogger, useClass: NGXLoggerMock },
                            { provide: ngxLogger.TOKEN_LOGGER_CONFIG, useValue: { level: ngxLogger.NgxLoggerLevel.ERROR } },
                            { provide: ngxLogger.TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, useClass: NGXLoggerConfigEngineFactoryMock },
                            { provide: ngxLogger.TOKEN_LOGGER_METADATA_SERVICE, useClass: NGXLoggerMetadataServiceMock },
                            { provide: ngxLogger.TOKEN_LOGGER_RULES_SERVICE, useClass: NGXLoggerRulesServiceMock },
                            { provide: ngxLogger.TOKEN_LOGGER_MAPPER_SERVICE, useClass: NGXLoggerMapperServiceMock },
                            { provide: ngxLogger.TOKEN_LOGGER_WRITER_SERVICE, useClass: NGXLoggerWriterServiceMock },
                            { provide: ngxLogger.TOKEN_LOGGER_SERVER_SERVICE, useClass: NGXLoggerServerServiceMock },
                            { provide: ngxLogger.CustomNGXLoggerService, useClass: CustomNGXLoggerServiceMock },
                        ]
                    }]
            }], null, null);
    })();

    /**
     * Generated bundle index. Do not edit.
     */

    exports.CustomNGXLoggerServiceMock = CustomNGXLoggerServiceMock;
    exports.LoggerTestingModule = LoggerTestingModule;
    exports.NGXLoggerConfigEngineFactoryMock = NGXLoggerConfigEngineFactoryMock;
    exports.NGXLoggerConfigEngineMock = NGXLoggerConfigEngineMock;
    exports.NGXLoggerMapperServiceMock = NGXLoggerMapperServiceMock;
    exports.NGXLoggerMetadataServiceMock = NGXLoggerMetadataServiceMock;
    exports.NGXLoggerMock = NGXLoggerMock;
    exports.NGXLoggerRulesServiceMock = NGXLoggerRulesServiceMock;
    exports.NGXLoggerServerServiceMock = NGXLoggerServerServiceMock;
    exports.NGXLoggerWriterServiceMock = NGXLoggerWriterServiceMock;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-logger-testing.umd.js.map
