{"version":3,"sources":["../../../src/lib/config/iconfig.ts","../../../src/lib/config/config-engine.ts","../../../src/lib/config/iconfig-engine-factory.ts","../../../src/lib/config/config-engine-factory.ts","../../../src/lib/mapper/imapper.service.ts","../../../src/lib/mapper/mapper.service.ts","../../../src/lib/metadata/imetadata.service.ts","../../../src/lib/metadata/metadata.service.ts","../../../src/lib/monitor/logger-monitor.ts","../../../src/lib/rules/irules.service.ts","../../../src/lib/rules/rules.service.ts","../../../src/lib/server/iserver.service.ts","../../../src/lib/server/server.service.ts","../../../src/lib/writer/iwriter.service.ts","../../../node_modules/tslib/tslib.es6.js","../../../src/lib/types/logger-level.enum.ts","../../../src/lib/writer/color-scheme.ts","../../../src/lib/writer/writer.service.ts","../../../src/lib/logger.service.ts","../../../src/lib/custom-logger.service.ts","../../../src/lib/logger.module.ts"],"names":["TOKEN_LOGGER_CONFIG","NGXLoggerConfigEngine","config","this","_clone","Object","defineProperty","prototype","level","serverLogLevel","updateConfig","getConfig","object","cloneConfig","keys","forEach","key","TOKEN_LOGGER_CONFIG_ENGINE_FACTORY","NGXLoggerConfigEngineFactory","provideConfigEngine","TOKEN_LOGGER_MAPPER_SERVICE","NGXLoggerMapperService","httpBackend","sourceMapCache","Map","logPositionCache","getLogPosition","metadata","stackLine","getStackLine","of","fileName","lineNumber","columnNumber","logPosition","getLocalPosition","enableSourceMaps","sourceMapLocation","getSourceMapLocation","getSourceMap","error","Error","e","defaultProxy","stack","split","includes","proxiedSteps","positionStartIndex","lastIndexOf","positionEndIndex","indexOf","undefined","dataArray","substring","length","getTranspileLocation","locationStartIndex","locationEndIndex","file","mapFullPath","getMapping","sourceMap","position","sourceFileIndex","sourceCodeLine","sourceCodeColumn","lines","mappings","lineIndex","generatedCodeColumn","columns","columnIndex","decodedSection","vlq.decode","sources","distPosition","_this","req","HttpRequest","distPositionKey","has","get","set","handle","pipe","filter","HttpResponse","map","httpResponse","body","retry","shareReplay","console","logPosition$","catchError","i0","ɵɵinject","i1","HttpBackend","factory","ɵfac","Injectable","Optional","TOKEN_LOGGER_METADATA_SERVICE","NGXLoggerMetadataService","datePipe","computeTimestamp","defaultTimestamp","Date","toISOString","timestampFormat","transform","getMetadata","message","additional","timestamp","i1$1","DatePipe","TOKEN_LOGGER_RULES_SERVICE","NGXLoggerRulesService","shouldCallWriter","disableConsoleLogging","shouldCallServer","serverLoggingUrl","shouldCallMonitor","TOKEN_LOGGER_SERVER_SERVICE","NGXLoggerServerService","secureErrorObject","err","secureAdditionalParameters","next","idx","JSON","stringify","secureMessage","logOnServer","url","logContent","options","customiseRequestBody","sendToServer","localMetadata","assign","requestBody","headers","customHttpHeaders","HttpHeaders","params","customHttpParams","HttpParams","responseType","httpResponseType","withCredentials","throwError","subscribe","TOKEN_LOGGER_WRITER_SERVICE","create","__read","o","n","m","Symbol","iterator","r","i","call","ar","done","push","value","__spread","arguments","concat","NgxLoggerLevel","DEFAULT_COLOR_SCHEME","NGXLoggerWriterService","platformId","isIE","isPlatformBrowser","navigator","userAgent","match","logFunc","logIE","bind","logModern","prepareMetaString","fileDetails","disableFileDetails","getColor","configColorScheme","_a","colorScheme","OFF","metaString","WARN","warn","apply","ERROR","FATAL","INFO","info","log","color","DEBUG","debug","writeMessage","PLATFORM_ID","Inject","NGXLogger","configEngineFactory","metadataService","ruleService","mapperService","writerService","serverService","configEngine","trace","_i","_log","TRACE","LOG","fatal","setCustomHttpHeaders","getConfigSnapshot","setCustomParams","setWithCredentialsOptionValue","registerMonitor","monitor","_loggerMonitor","take","onLog","providedIn","CustomNGXLoggerService","logMonitor","logger","LoggerModule","forRoot","customProvider","configProvider","provide","useValue","configEngineFactoryProvider","useClass","metadataProvider","ruleProvider","mapperProvider","writerProvider","serverProvider","ngModule","providers","forChild","CommonModule","imports","NgModule"],"mappings":"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","sourcesContent":["import { HttpHeaders, HttpParams } from \"@angular/common/http\";\r\nimport { NgxLoggerLevel } from \"../types/logger-level.enum\";\r\nimport { NGXLoggerColorScheme } from \"../writer/color-scheme\";\r\n\r\n/**\r\n * Injection token of logger config\r\n */\r\nexport const TOKEN_LOGGER_CONFIG = 'TOKEN_LOGGER_CONFIG';\r\n\r\n/**\r\n * Interface that defines logger config data\r\n * You can use your own logger config as long as it implements this interface\r\n */\r\nexport interface INGXLoggerConfig {\r\n  // Global config\r\n  /** Minimum level to be written */\r\n  level: NgxLoggerLevel;\r\n\r\n  // metadata-service config\r\n  /** Timestamp format: any format accepted by Angular DatePipe. Defaults to ISOString. If set you need to provide DatePipe from @angular/common */\r\n  timestampFormat?: string;\r\n\r\n  // rule-service config\r\n  /** If true the console logging won't be called */\r\n  disableConsoleLogging?: boolean;\r\n\r\n  // mapper-service config\r\n  /* If true, the logger will download sourcemaps to compute the file details */\r\n  enableSourceMaps?: boolean;\r\n  /** Number of calls that will be ignored when trying to get line of stacktrace */\r\n  proxiedSteps?: number;\r\n\r\n  // writer-service config\r\n  /** Defines the color to use depending on log level */\r\n  colorScheme?: NGXLoggerColorScheme;\r\n  /** If true the console log won't include file details (filename, line number and column number) */\r\n  disableFileDetails?: boolean;\r\n\r\n  // server-service config\r\n  /** Minimum level to be sent to server */\r\n  serverLogLevel?: NgxLoggerLevel;\r\n  /** URL used to send log to server */\r\n  serverLoggingUrl?: string;\r\n  /** If true, adds \"withCredentials\" options when sending log to server */\r\n  withCredentials?: boolean;\r\n  /** Http params that will be used when sending log to server */\r\n  customHttpParams?: HttpParams,\r\n  /** Http headers that will be used when sending log to server */\r\n  customHttpHeaders?: HttpHeaders,\r\n  /** Response type that will be used when sending log to server (defaults to json) */\r\n  httpResponseType?: \"arraybuffer\" | \"blob\" | \"text\" | \"json\";\r\n}\r\n","import { NgxLoggerLevel } from './../types/logger-level.enum';\r\nimport { INGXLoggerConfigEngine } from './iconfig-engine';\r\nimport { INGXLoggerConfig } from './iconfig';\r\n\r\nexport class NGXLoggerConfigEngine implements INGXLoggerConfigEngine {\r\n\r\n  private config: INGXLoggerConfig;\r\n\r\n  constructor(\r\n    config: INGXLoggerConfig,\r\n  ) {\r\n    this.config = this._clone(config);\r\n  }\r\n\r\n  /** Get a readonly access to the level configured for the NGXLogger */\r\n  get level(): NgxLoggerLevel {\r\n    return this.config.level;\r\n  }\r\n\r\n  /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\r\n  get serverLogLevel(): NgxLoggerLevel {\r\n    return this.config.serverLogLevel;\r\n  }\r\n\r\n  updateConfig(config: INGXLoggerConfig) {\r\n    this.config = this._clone(config);\r\n  }\r\n\r\n  getConfig(): INGXLoggerConfig {\r\n    return this._clone(this.config);\r\n  }\r\n\r\n  // TODO: This is a shallow clone, If the config ever becomes hierarchical we must make this a deep clone\r\n  private _clone(object: any) {\r\n    const cloneConfig: INGXLoggerConfig = { level: null };\r\n\r\n    Object.keys(object).forEach((key) => {\r\n      cloneConfig[key] = object[key];\r\n    });\r\n\r\n    return cloneConfig;\r\n  }\r\n}\r\n","import { INGXLoggerConfig } from \"./iconfig\";\r\nimport { INGXLoggerConfigEngine } from \"./iconfig-engine\";\r\n\r\n/**\r\n * Injection token of logger config engine factory\r\n */\r\nexport const TOKEN_LOGGER_CONFIG_ENGINE_FACTORY = 'TOKEN_LOGGER_CONFIG_ENGINE_FACTORY';\r\n\r\nexport interface INGXLoggerConfigEngineFactory {\r\n  /** Create the instance of configEngine */\r\n  provideConfigEngine(config: INGXLoggerConfig): INGXLoggerConfigEngine;\r\n}\r\n","import { INGXLoggerConfig } from \"./iconfig\";\r\nimport { NGXLoggerConfigEngine } from \"./config-engine\";\r\nimport { INGXLoggerConfigEngine } from \"./iconfig-engine\";\r\nimport { INGXLoggerConfigEngineFactory } from \"./iconfig-engine-factory\";\r\n\r\nexport class NGXLoggerConfigEngineFactory implements INGXLoggerConfigEngineFactory {\r\n\r\n  provideConfigEngine(config: INGXLoggerConfig): INGXLoggerConfigEngine {\r\n    return new NGXLoggerConfigEngine(config);\r\n  }\r\n\r\n}\r\n","import { INGXLoggerConfig } from \"../config/iconfig\";\r\nimport { INGXLoggerMetadata } from \"../metadata/imetadata\";\r\nimport { INGXLoggerLogPosition } from \"./ilog-position\";\r\nimport { Observable } from \"rxjs\";\r\n\r\n/**\r\n * Injection token of logger mapper service\r\n */\r\nexport const TOKEN_LOGGER_MAPPER_SERVICE = 'TOKEN_LOGGER_MAPPER_SERVICE';\r\n\r\nexport interface INGXLoggerMapperService {\r\n  /**\r\n   * Returns the log position of the caller\r\n   * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the position\r\n   * @param config \r\n   * @param metadata \r\n   * @returns \r\n   */\r\n  getLogPosition(config: INGXLoggerConfig, metadata: INGXLoggerMetadata): Observable<INGXLoggerLogPosition>;\r\n}\r\n","import { HttpBackend, HttpRequest, HttpResponse } from '@angular/common/http';\r\nimport { SourceMap } from '@angular/compiler';\r\nimport { Injectable, Optional } from '@angular/core';\r\nimport { Observable, of } from 'rxjs';\r\nimport { catchError, filter, map, retry, shareReplay } from 'rxjs/operators';\r\nimport * as vlq from 'vlq';\r\nimport { INGXLoggerConfig } from '../config/iconfig';\r\nimport { INGXLoggerMetadata } from '../metadata/imetadata';\r\nimport { INGXLoggerLogPosition } from './ilog-position';\r\nimport { INGXLoggerMapperService } from './imapper.service';\r\n\r\n@Injectable()\r\nexport class NGXLoggerMapperService implements INGXLoggerMapperService {\r\n\r\n  /** cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map' */\r\n  protected sourceMapCache: Map<string, Observable<SourceMap>> = new Map();\r\n\r\n  /** cache for specific log position, key is the dist position, ie 'main.js:339:21' */\r\n  protected logPositionCache: Map<string, Observable<INGXLoggerLogPosition>> = new Map();\r\n\r\n  constructor(\r\n    @Optional() private httpBackend: HttpBackend\r\n  ) {\r\n  }\r\n\r\n  /**\r\n   * Returns the log position of the caller\r\n   * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the position\r\n   * @param config \r\n   * @param metadata \r\n   * @returns \r\n   */\r\n  public getLogPosition(config: INGXLoggerConfig, metadata: INGXLoggerMetadata): Observable<INGXLoggerLogPosition> {\r\n    const stackLine = this.getStackLine(config);\r\n\r\n    // if we were not able to parse the stackLine, just return an empty Log Position\r\n    if (!stackLine) {\r\n      return of({ fileName: '', lineNumber: 0, columnNumber: 0 });\r\n    }\r\n\r\n    const logPosition = this.getLocalPosition(stackLine);\r\n\r\n    if (!config.enableSourceMaps) {\r\n      return of(logPosition);\r\n    }\r\n\r\n    const sourceMapLocation = this.getSourceMapLocation(stackLine);\r\n    return this.getSourceMap(sourceMapLocation, logPosition);\r\n  }\r\n\r\n  /**\r\n   * Get the stackline of the original caller\r\n   * @param config \r\n   * @returns null if stackline was not found\r\n   */\r\n  protected getStackLine(config: INGXLoggerConfig): string {\r\n    const error = new Error();\r\n\r\n    try {\r\n      // noinspection ExceptionCaughtLocallyJS\r\n      throw error;\r\n    } catch (e) {\r\n\r\n      try {\r\n        // Here are different examples of stacktrace \r\n\r\n        // Firefox (last line is the user code, the 4 first are ours):\r\n        // getStackLine@http://localhost:4200/main.js:358:23\r\n        // getCallerDetails@http://localhost:4200/main.js:557:44\r\n        // _log@http://localhost:4200/main.js:830:28\r\n        // debug@http://localhost:4200/main.js:652:14\r\n        // handleLog@http://localhost:4200/main.js:1158:29\r\n\r\n        // Chrome and Edge (last line is the user code):\r\n        // Error\r\n        // at Function.getStackLine (ngx-logger.js:329)\r\n        // at NGXMapperService.getCallerDetails (ngx-logger.js:528)\r\n        // at NGXLogger._log (ngx-logger.js:801)\r\n        // at NGXLogger.info (ngx-logger.js:631)\r\n        // at AppComponent.handleLog (app.component.ts:38)\r\n\r\n        let defaultProxy = 4; // We make 4 functions call before getting here\r\n        const firstStackLine = error.stack.split('\\n')[0];\r\n        if (!firstStackLine.includes('.js:')) {\r\n          // The stacktrace starts with no function call (example in Chrome or Edge)\r\n          defaultProxy = defaultProxy + 1;\r\n        }\r\n\r\n        return error.stack.split('\\n')[(defaultProxy + (config.proxiedSteps || 0))];\r\n      } catch (e) {\r\n        return null;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get position of caller without using sourceMaps\r\n   * @param stackLine \r\n   * @returns \r\n   */\r\n  protected getLocalPosition(stackLine: string): INGXLoggerLogPosition {\r\n    // strip base path, then parse filename, line, and column, stackline looks like this :\r\n    // Firefox\r\n    // handleLog@http://localhost:4200/main.js:1158:29\r\n    // Chrome and Edge\r\n    // at AppComponent.handleLog (app.component.ts:38)\r\n\r\n    const positionStartIndex = stackLine.lastIndexOf('\\/');\r\n    let positionEndIndex = stackLine.indexOf(')');\r\n    if (positionEndIndex < 0) {\r\n      positionEndIndex = undefined;\r\n    }\r\n\r\n    const position = stackLine.substring(positionStartIndex + 1, positionEndIndex);\r\n    const dataArray = position.split(':');\r\n    if (dataArray.length === 3) {\r\n      return { fileName: dataArray[0], lineNumber: +dataArray[1], columnNumber: +dataArray[2] };\r\n    }\r\n    return { fileName: 'unknown', lineNumber: 0, columnNumber: 0 };\r\n  }\r\n\r\n  private getTranspileLocation(stackLine: string): string {\r\n    // Example stackLine:\r\n    // Firefox : getStackLine@http://localhost:4200/main.js:358:23\r\n    // Chrome and Edge : at Function.getStackLine (ngx-logger.js:329)\r\n    let locationStartIndex = stackLine.indexOf('(');\r\n    if (locationStartIndex < 0) {\r\n      locationStartIndex = stackLine.lastIndexOf('@');\r\n      if (locationStartIndex < 0) {\r\n        locationStartIndex = stackLine.lastIndexOf(' ');\r\n      }\r\n    }\r\n\r\n    let locationEndIndex = stackLine.indexOf(')');\r\n    if (locationEndIndex < 0) {\r\n      locationEndIndex = undefined;\r\n    }\r\n\r\n    return stackLine.substring(locationStartIndex + 1, locationEndIndex);\r\n  }\r\n\r\n  /**\r\n   * Gets the URL of the sourcemap (the URL can be relative or absolute, it is browser dependant)\r\n   * @param stackLine \r\n   * @returns \r\n   */\r\n  protected getSourceMapLocation(stackLine: string): string {\r\n    const file = this.getTranspileLocation(stackLine);\r\n    const mapFullPath = file.substring(0, file.lastIndexOf(':'));\r\n    return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';\r\n  }\r\n\r\n  private getMapping(sourceMap: SourceMap, position: INGXLoggerLogPosition): INGXLoggerLogPosition {\r\n    // => ';' indicates end of a line\r\n    // => ',' separates mappings in a line\r\n    // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]\r\n    let sourceFileIndex = 0,   // second field\r\n      sourceCodeLine = 0,    // third field\r\n      sourceCodeColumn = 0;  // fourth field\r\n\r\n    const lines = sourceMap.mappings.split(';');\r\n\r\n    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\r\n      // reset column position to 0 after each line\r\n      let generatedCodeColumn = 0;\r\n      // decode sections in line\r\n      const columns = lines[lineIndex].split(',');\r\n\r\n      for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {\r\n        const decodedSection = vlq.decode(columns[columnIndex]);\r\n        if (decodedSection.length >= 4) {\r\n          // update relative positions\r\n          generatedCodeColumn += decodedSection[0];\r\n          sourceFileIndex += decodedSection[1];\r\n          sourceCodeLine += decodedSection[2];\r\n          sourceCodeColumn += decodedSection[3];\r\n        }\r\n\r\n        // check if matching map\r\n        if (lineIndex === position.lineNumber) {\r\n          if (generatedCodeColumn === position.columnNumber) {\r\n            // matching column and line found\r\n            return { fileName: sourceMap.sources[sourceFileIndex], lineNumber: sourceCodeLine, columnNumber: sourceCodeColumn };\r\n          } else if (columnIndex + 1 === columns.length) {\r\n            // matching column not found, but line is correct\r\n            return { fileName: sourceMap.sources[sourceFileIndex], lineNumber: sourceCodeLine, columnNumber: 0 };\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // failed if reached\r\n    return { fileName: 'unknown', lineNumber: 0, columnNumber: 0 };\r\n  }\r\n\r\n  /**\r\n   * does the http get request to get the source map\r\n   * @param sourceMapLocation\r\n   * @param distPosition\r\n   */\r\n  protected getSourceMap(sourceMapLocation: string, distPosition: INGXLoggerLogPosition): Observable<INGXLoggerLogPosition> {\r\n    const req = new HttpRequest<SourceMap>('GET', sourceMapLocation);\r\n    const distPositionKey = `${distPosition.fileName}:${distPosition.lineNumber}:${distPosition.columnNumber}`;\r\n\r\n    // if the specific log position is already in cache return it\r\n    if (this.logPositionCache.has(distPositionKey)) {\r\n      return this.logPositionCache.get(distPositionKey);\r\n    }\r\n\r\n    // otherwise check if the source map is already cached for given source map location\r\n    if (!this.sourceMapCache.has(sourceMapLocation)) {\r\n      if (!this.httpBackend) {\r\n        console.error('NGXLogger : Can\\'t get sourcemap because HttpBackend is not provided. You need to import HttpClientModule');\r\n        this.sourceMapCache.set(sourceMapLocation, of(null));\r\n      } else {\r\n        // obtain the source map if not cached\r\n        this.sourceMapCache.set(\r\n          sourceMapLocation,\r\n          this.httpBackend.handle(req).pipe(\r\n            filter((e) => e instanceof HttpResponse),\r\n            map<HttpResponse<SourceMap>, SourceMap>(\r\n              (httpResponse: HttpResponse<SourceMap>) => httpResponse.body\r\n            ),\r\n            retry(3),\r\n            shareReplay(1)\r\n          )\r\n        );\r\n      }\r\n    }\r\n\r\n    // at this point the source map is cached, use it to get specific log position mapping\r\n    const logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(\r\n      map<SourceMap, INGXLoggerLogPosition>((sourceMap) => {\r\n        // sourceMap can be null if HttpBackend is not provided for example\r\n        if (!sourceMap) {\r\n          return distPosition;\r\n        }\r\n        // map generated position to source position\r\n        return this.getMapping(sourceMap, distPosition)\r\n      }),\r\n      catchError(() => of(distPosition)),\r\n      shareReplay(1)\r\n    );\r\n\r\n    // store specific log position in cache for given dest position and return it\r\n    this.logPositionCache.set(distPositionKey, logPosition$);\r\n\r\n    return logPosition$;\r\n  }\r\n}\r\n","import { INGXLoggerConfig } from \"../config/iconfig\";\r\nimport { NgxLoggerLevel } from \"../types/logger-level.enum\";\r\nimport { INGXLoggerMetadata } from \"./imetadata\";\r\n\r\n/**\r\n * Injection token of logger metadata service\r\n */\r\nexport const TOKEN_LOGGER_METADATA_SERVICE = 'TOKEN_LOGGER_METADATA_SERVICE';\r\n\r\nexport interface INGXLoggerMetadataService {\r\n  /**\r\n   * Gets the content to be logged and some metadata around it\r\n   * @param level \r\n   * @param config \r\n   * @param message \r\n   * @param additional \r\n   */\r\n  getMetadata(level: NgxLoggerLevel, config: INGXLoggerConfig, message?: any | (() => any), additional?: any[]): INGXLoggerMetadata;\r\n}\r\n","import { DatePipe } from '@angular/common';\r\nimport { Injectable, Optional } from '@angular/core';\r\nimport { NgxLoggerLevel } from '../types/logger-level.enum';\r\nimport { INGXLoggerConfig } from '../config/iconfig';\r\nimport { INGXLoggerMetadata } from './imetadata';\r\nimport { INGXLoggerMetadataService } from './imetadata.service';\r\n\r\n@Injectable()\r\nexport class NGXLoggerMetadataService implements INGXLoggerMetadataService {\r\n\r\n  constructor(\r\n    @Optional() protected readonly datePipe: DatePipe,\r\n  ) { }\r\n\r\n  protected computeTimestamp(config: INGXLoggerConfig): string {\r\n    const defaultTimestamp = () => new Date().toISOString();\r\n\r\n    if (config.timestampFormat) {\r\n      if (!this.datePipe) {\r\n        console.error('NGXLogger : Can\\'t use timeStampFormat because DatePipe is not provided. You need to provide DatePipe');\r\n        return defaultTimestamp();\r\n      } else {\r\n        return this.datePipe.transform(new Date(), config.timestampFormat);\r\n      }\r\n    }\r\n\r\n    return defaultTimestamp();\r\n  }\r\n\r\n  public getMetadata(\r\n    level: NgxLoggerLevel,\r\n    config: INGXLoggerConfig,\r\n    message?: any | (() => any),\r\n    additional?: any[],\r\n  ): INGXLoggerMetadata {\r\n    const metadata: INGXLoggerMetadata = {\r\n      level: level,\r\n      additional: additional,\r\n    };\r\n\r\n    // The user can send a function\r\n    // This is useful in order to compute string concatenation only when the log will actually be written\r\n    if (message && typeof message === 'function') {\r\n      metadata.message = message();\r\n    } else {\r\n      metadata.message = message;\r\n    }\r\n\r\n    metadata.timestamp = this.computeTimestamp(config);\r\n\r\n    return metadata;\r\n  }\r\n}\r\n","import { INGXLoggerConfig } from '../config/iconfig';\r\nimport { INGXLoggerMetadata } from '../metadata/imetadata';\r\nimport { INGXLoggerMonitor } from './ilogger-monitor';\r\n\r\n// I kept this class alive only to avoid a breaking change with the old version\r\n// This class does not implement anything so it is useless and the interface is enough\r\n\r\n/**\r\n * @deprecated this class does not implement anything thus being useless, you should rather implements @see INGXLoggerMonitor\r\n */\r\nexport abstract class NGXLoggerMonitor implements INGXLoggerMonitor {\r\n  abstract onLog(logObject: INGXLoggerMetadata, config: INGXLoggerConfig): void;\r\n}\r\n","import { INGXLoggerConfig } from \"../config/iconfig\";\r\nimport { NgxLoggerLevel } from \"../types/logger-level.enum\";\r\n\r\n/**\r\n * Injection token of logger metadata service\r\n */\r\nexport const TOKEN_LOGGER_RULES_SERVICE = 'TOKEN_LOGGER_RULES_SERVICE';\r\n\r\n/**\r\n * Service used to know if some of the feature of the logger should be used or not\r\n */\r\nexport interface INGXLoggerRulesService {\r\n  /**\r\n   * If true the logger will write logs to console\r\n   * @param level \r\n   * @param config \r\n   * @param message \r\n   * @param additional \r\n   */\r\n  shouldCallWriter(level: NgxLoggerLevel, config: INGXLoggerConfig, message?: any | (() => any), additional?: any[]): boolean;\r\n  /**\r\n   * If true the logger will send logs to server\r\n   * @param level \r\n   * @param config \r\n   * @param message \r\n   * @param additional \r\n   */\r\n  shouldCallServer(level: NgxLoggerLevel, config: INGXLoggerConfig, message?: any | (() => any), additional?: any[]): boolean;\r\n  /**\r\n   * If true the logger will call the loggerMonitor\r\n   * @param level \r\n   * @param config \r\n   * @param message \r\n   * @param additional \r\n   */\r\n  shouldCallMonitor(level: NgxLoggerLevel, config: INGXLoggerConfig, message?: any | (() => any), additional?: any[]): boolean;\r\n}\r\n","import { Injectable } from '@angular/core';\r\nimport { NgxLoggerLevel } from '../types/logger-level.enum';\r\nimport { INGXLoggerConfig } from '../config/iconfig';\r\nimport { INGXLoggerRulesService } from './irules.service';\r\n\r\n@Injectable()\r\nexport class NGXLoggerRulesService implements INGXLoggerRulesService {\r\n\r\n  public shouldCallWriter(level: NgxLoggerLevel, config: INGXLoggerConfig, message?: any, additional?: any[]): boolean {\r\n    return !config.disableConsoleLogging && level >= config.level;\r\n  }\r\n\r\n  public shouldCallServer(level: NgxLoggerLevel, config: INGXLoggerConfig, message?: any, additional?: any[]): boolean {\r\n    return !!config.serverLoggingUrl && level >= config.serverLogLevel;\r\n  }\r\n\r\n  public shouldCallMonitor(level: NgxLoggerLevel, config: INGXLoggerConfig, message?: any, additional?: any[]): boolean {\r\n    // The default behavior is to call the monitor only if the writer or the server is called\r\n    return this.shouldCallWriter(level, config, message, additional) || this.shouldCallServer(level, config, message, additional);\r\n  }\r\n}\r\n","import { INGXLoggerConfig } from \"../config/iconfig\";\r\nimport { INGXLoggerMetadata } from \"../metadata/imetadata\";\r\n\r\n/**\r\n * Injection token of logger server service\r\n */\r\nexport const TOKEN_LOGGER_SERVER_SERVICE = 'TOKEN_LOGGER_SERVER_SERVICE';\r\n\r\nexport interface INGXLoggerServerService {\r\n  /**\r\n   * Sends the content to be logged to the server according to the config\r\n   * @param metadata \r\n   * @param config \r\n   */\r\n  sendToServer(metadata: INGXLoggerMetadata, config: INGXLoggerConfig): void;\r\n}\r\n","import { HttpBackend, HttpHeaders, HttpParams, HttpRequest, HttpResponse } from '@angular/common/http';\r\nimport { Injectable, Optional } from '@angular/core';\r\nimport { Observable, of, throwError } from 'rxjs';\r\nimport { catchError, filter, map } from 'rxjs/operators';\r\nimport { INGXLoggerMetadata } from '../metadata/imetadata';\r\nimport { INGXLoggerConfig } from '../config/iconfig';\r\nimport { INGXLoggerServerService } from './iserver.service';\r\n\r\n@Injectable()\r\nexport class NGXLoggerServerService implements INGXLoggerServerService {\r\n\r\n  constructor(\r\n    @Optional() protected readonly httpBackend: HttpBackend,\r\n  ) { }\r\n\r\n  /**\r\n   * Transforms an error object into a readable string (taking only the stack)\r\n   * This is needed because JSON.stringify would return \"{}\"\r\n   * @param err the error object\r\n   * @returns The stack of the error\r\n   */\r\n  protected secureErrorObject(err: Error): string {\r\n    return err?.stack;\r\n  }\r\n\r\n  /**\r\n   * Transforms the additional parameters to avoid any json error when sending the data to the server\r\n   * Basically it just replaces unstringifiable object to a string mentioning an error\r\n   * @param additional The additional data to be sent\r\n   * @returns The additional data secured\r\n   */\r\n  protected secureAdditionalParameters(additional: any[]): any[] {\r\n    if (additional === null || additional === undefined) {\r\n      return null;\r\n    }\r\n\r\n    return additional.map((next, idx) => {\r\n      try {\r\n        if (next instanceof Error) {\r\n          return this.secureErrorObject(next);\r\n        }\r\n        // We just want to make sure the JSON can be parsed, we do not want to actually change the type\r\n        if (typeof next === 'object') {\r\n          JSON.stringify(next);\r\n        }\r\n\r\n        return next;\r\n      } catch (e) {\r\n        return `The additional[${idx}] value could not be parsed using JSON.stringify().`;\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Transforms the message so that it can be sent to the server\r\n   * @param message the message to be sent\r\n   * @returns the message secured\r\n   */\r\n  protected secureMessage(message: any): string {\r\n    try {\r\n      if (message instanceof Error) {\r\n        return this.secureErrorObject(message);\r\n      }\r\n\r\n      if (typeof message !== 'string') {\r\n        message = JSON.stringify(message, null, 2);\r\n      }\r\n    } catch (e) {\r\n      message = 'The provided \"message\" value could not be parsed with JSON.stringify().';\r\n    }\r\n\r\n    return message;\r\n  }\r\n\r\n  protected logOnServer<T>(\r\n    url: string,\r\n    logContent: T,\r\n    options: {\r\n      headers?: HttpHeaders;\r\n      reportProgress?: boolean;\r\n      params?: HttpParams;\r\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text';\r\n      withCredentials?: boolean;\r\n    },\r\n  ): Observable<T> {\r\n    // HttpBackend skips all HttpInterceptors\r\n    // They may log errors using this service causing circular calls\r\n    const req = new HttpRequest<T>('POST', url, logContent, options || {});\r\n\r\n    if (!this.httpBackend) {\r\n      console.error('NGXLogger : Can\\'t log on server because HttpBackend is not provided. You need to import HttpClientModule');\r\n      return of(null);\r\n    }\r\n    return this.httpBackend.handle(req).pipe(\r\n      filter(e => e instanceof HttpResponse),\r\n      map<HttpResponse<T>, T>((httpResponse: HttpResponse<T>) => httpResponse.body)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Customise the data sent to the API\r\n   * @param metadata the data provided by NGXLogger\r\n   * @returns the data that will be sent to the API in the body\r\n   */\r\n  protected customiseRequestBody(metadata: INGXLoggerMetadata): any {\r\n    // In our API the body is not customised\r\n    return metadata;\r\n  }\r\n\r\n  public sendToServer(metadata: INGXLoggerMetadata, config: INGXLoggerConfig): void {\r\n    // Copying metadata locally because we don't want to change the object for the caller\r\n    const localMetadata = { ...metadata };\r\n\r\n    localMetadata.additional = this.secureAdditionalParameters(localMetadata.additional);\r\n\r\n    localMetadata.message = this.secureMessage(localMetadata.message);\r\n\r\n    // Allow users to customise the data sent to the API\r\n    const requestBody = this.customiseRequestBody(localMetadata);\r\n\r\n    const headers = config.customHttpHeaders || new HttpHeaders();\r\n    if (!headers.has('Content-Type')) {\r\n      headers.set('Content-Type', 'application/json');\r\n    }\r\n\r\n    this.logOnServer<any>(config.serverLoggingUrl, requestBody, {\r\n      headers,\r\n      params: config.customHttpParams || new HttpParams(),\r\n      responseType: config.httpResponseType || 'json',\r\n      withCredentials: config.withCredentials || false,\r\n    }).pipe(catchError(err => {\r\n      // Do not use NGXLogger here because this could cause an infinite loop \r\n      console.error('NGXLogger: Failed to log on server', err);\r\n      return throwError(err);\r\n    })).subscribe();\r\n  }\r\n}\r\n","import { INGXLoggerConfig } from \"../config/iconfig\";\r\nimport { INGXLoggerMetadata } from \"../metadata/imetadata\";\r\n\r\n/**\r\n * Injection token of logger writer service\r\n */\r\nexport const TOKEN_LOGGER_WRITER_SERVICE = 'TOKEN_LOGGER_WRITER_SERVICE';\r\n\r\nexport interface INGXLoggerWriterService {\r\n  /**\r\n   * Write content to the console\r\n   * @param metadata \r\n   * @param config \r\n   */\r\n  writeMessage(metadata: INGXLoggerMetadata, config: INGXLoggerConfig): void;\r\n}\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n","export enum NgxLoggerLevel {\r\n  TRACE = 0,\r\n  DEBUG = 1,\r\n  INFO = 2,\r\n  LOG = 3,\r\n  WARN = 4,\r\n  ERROR = 5,\r\n  FATAL = 6,\r\n  OFF = 7\r\n}\r\n","export type NGXLoggerColorScheme = [string, string, string, string, string, string, string];\r\n\r\nexport const DEFAULT_COLOR_SCHEME: NGXLoggerColorScheme = [\r\n  'purple',\r\n  'teal',\r\n  'gray',\r\n  'gray',\r\n  'red',\r\n  'red',\r\n  'red'\r\n];\r\n","import { Inject, Injectable, PLATFORM_ID } from '@angular/core';\r\nimport { INGXLoggerMetadata } from '../metadata/imetadata';\r\nimport { INGXLoggerConfig } from '../config/iconfig';\r\nimport { INGXLoggerWriterService } from './iwriter.service';\r\nimport { isPlatformBrowser } from '@angular/common';\r\nimport { NgxLoggerLevel } from '../types/logger-level.enum';\r\nimport { DEFAULT_COLOR_SCHEME } from './color-scheme';\r\n\r\n@Injectable()\r\nexport class NGXLoggerWriterService implements INGXLoggerWriterService {\r\n\r\n  protected readonly isIE: boolean;\r\n  protected readonly logFunc: (metadata: INGXLoggerMetadata, config: INGXLoggerConfig, metaString: string) => void;\r\n\r\n  constructor(\r\n    @Inject(PLATFORM_ID) protected platformId,\r\n  ) {\r\n    this.isIE = isPlatformBrowser(platformId) && navigator && navigator.userAgent &&\r\n      !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\\//) || navigator.userAgent.match(/Edge\\//));\r\n\r\n    this.logFunc = this.isIE ? this.logIE.bind(this) : this.logModern.bind(this);\r\n  }\r\n\r\n  /** Generate a \"meta\" string that is displayed before the content sent to the log function */\r\n  protected prepareMetaString(metadata: INGXLoggerMetadata, config: INGXLoggerConfig): string {\r\n\t\tconst fileDetails = config.disableFileDetails === true ? '' : `[${metadata.fileName}:${metadata.lineNumber}:${metadata.columnNumber}]`;\r\n\r\n    return `${metadata.timestamp} ${NgxLoggerLevel[metadata.level]} ${fileDetails}`;\r\n  }\r\n\r\n  /** Get the color to use when writing to console */\r\n  protected getColor(metadata: INGXLoggerMetadata, config: INGXLoggerConfig): string | undefined {\r\n    const configColorScheme = config.colorScheme ?? DEFAULT_COLOR_SCHEME;\r\n\r\n    // this is needed to avoid a build error\r\n    if (metadata.level === NgxLoggerLevel.OFF) {\r\n      return undefined;\r\n    }\r\n    return configColorScheme[metadata.level];\r\n  }\r\n\r\n  /** Log to the console specifically for IE */\r\n  protected logIE(metadata: INGXLoggerMetadata, config: INGXLoggerConfig, metaString: string): void {\r\n\r\n    // Coloring doesn't work in IE\r\n\r\n    // make sure additional isn't null or undefined so that ...additional doesn't error\r\n    const additional = metadata.additional || [];\r\n\r\n    switch (metadata.level) {\r\n      case NgxLoggerLevel.WARN:\r\n        console.warn(`${metaString} `, metadata.message, ...additional);\r\n        break;\r\n      case NgxLoggerLevel.ERROR:\r\n      case NgxLoggerLevel.FATAL:\r\n        console.error(`${metaString} `, metadata.message, ...additional);\r\n        break;\r\n      case NgxLoggerLevel.INFO:\r\n        console.info(`${metaString} `, metadata.message, ...additional);\r\n        break;\r\n      default:\r\n        console.log(`${metaString} `, metadata.message, ...additional);\r\n    }\r\n  }\r\n\r\n  /** Log to the console */\r\n  protected logModern(metadata: INGXLoggerMetadata, config: INGXLoggerConfig, metaString: string): void {\r\n    const color = this.getColor(metadata, config);\r\n\r\n    // make sure additional isn't null or undefined so that ...additional doesn't error\r\n    const additional = metadata.additional || [];\r\n\r\n    switch (metadata.level) {\r\n      case NgxLoggerLevel.WARN:\r\n        console.warn(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n        break;\r\n      case NgxLoggerLevel.ERROR:\r\n      case NgxLoggerLevel.FATAL:\r\n        console.error(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n        break;\r\n      case NgxLoggerLevel.INFO:\r\n        console.info(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n        break;\r\n      //  Disabling console.trace since the stack trace is not helpful. it is showing the stack trace of\r\n      // the console.trace statement\r\n      // case NgxLoggerLevel.TRACE:\r\n      //   console.trace(`%c${metaString}`, `color:${color}`, message, ...additional);\r\n      //   break;\r\n\r\n      case NgxLoggerLevel.DEBUG:\r\n        console.debug(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n        break;\r\n      default:\r\n        console.log(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n    }\r\n  }\r\n\r\n  /** Write the content sent to the log function to the console */\r\n  public writeMessage(metadata: INGXLoggerMetadata, config: INGXLoggerConfig): void {\r\n    const metaString = this.prepareMetaString(metadata, config);\r\n\r\n    this.logFunc(metadata, config, metaString);\r\n  }\r\n}\r\n","import { Inject, Injectable } from '@angular/core';\r\nimport { HttpHeaders, HttpParams } from '@angular/common/http';\r\nimport { NgxLoggerLevel } from './types/logger-level.enum';\r\nimport { INGXLoggerConfigEngine } from './config/iconfig-engine';\r\nimport { INGXLoggerConfig, TOKEN_LOGGER_CONFIG } from './config/iconfig';\r\nimport { INGXLoggerMetadataService, TOKEN_LOGGER_METADATA_SERVICE } from './metadata/imetadata.service';\r\nimport { INGXLoggerRulesService, TOKEN_LOGGER_RULES_SERVICE } from './rules/irules.service';\r\nimport { INGXLoggerMapperService, TOKEN_LOGGER_MAPPER_SERVICE } from './mapper/imapper.service';\r\nimport { INGXLoggerMonitor } from './monitor/ilogger-monitor';\r\nimport { INGXLoggerWriterService, TOKEN_LOGGER_WRITER_SERVICE } from './writer/iwriter.service';\r\nimport { INGXLoggerServerService, TOKEN_LOGGER_SERVER_SERVICE } from './server/iserver.service';\r\nimport { take } from 'rxjs/operators';\r\nimport { INGXLoggerConfigEngineFactory, TOKEN_LOGGER_CONFIG_ENGINE_FACTORY } from './config/iconfig-engine-factory';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class NGXLogger {\r\n  private _loggerMonitor: INGXLoggerMonitor;\r\n  private configEngine: INGXLoggerConfigEngine;\r\n\r\n  constructor(\r\n    @Inject(TOKEN_LOGGER_CONFIG) config: INGXLoggerConfig,\r\n    @Inject(TOKEN_LOGGER_CONFIG_ENGINE_FACTORY) configEngineFactory: INGXLoggerConfigEngineFactory,\r\n    @Inject(TOKEN_LOGGER_METADATA_SERVICE) private metadataService: INGXLoggerMetadataService,\r\n    @Inject(TOKEN_LOGGER_RULES_SERVICE) private ruleService: INGXLoggerRulesService,\r\n    @Inject(TOKEN_LOGGER_MAPPER_SERVICE) private mapperService: INGXLoggerMapperService,\r\n    @Inject(TOKEN_LOGGER_WRITER_SERVICE) private writerService: INGXLoggerWriterService,\r\n    @Inject(TOKEN_LOGGER_SERVER_SERVICE) private serverService: INGXLoggerServerService,\r\n  ) {\r\n    this.configEngine = configEngineFactory.provideConfigEngine(config);\r\n  }\r\n\r\n  /** Get a readonly access to the level configured for the NGXLogger */\r\n  get level(): NgxLoggerLevel {\r\n    return this.configEngine.level;\r\n  }\r\n\r\n  /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\r\n  get serverLogLevel(): NgxLoggerLevel {\r\n    return this.configEngine.serverLogLevel;\r\n  }\r\n\r\n  public trace(message?: any | (() => any), ...additional: any[]): void {\r\n    this._log(NgxLoggerLevel.TRACE, message, additional);\r\n  }\r\n\r\n  public debug(message?: any | (() => any), ...additional: any[]): void {\r\n    this._log(NgxLoggerLevel.DEBUG, message, additional);\r\n  }\r\n\r\n  public info(message?: any | (() => any), ...additional: any[]): void {\r\n    this._log(NgxLoggerLevel.INFO, message, additional);\r\n  }\r\n\r\n  public log(message?: any | (() => any), ...additional: any[]): void {\r\n    this._log(NgxLoggerLevel.LOG, message, additional);\r\n  }\r\n\r\n  public warn(message?: any | (() => any), ...additional: any[]): void {\r\n    this._log(NgxLoggerLevel.WARN, message, additional);\r\n  }\r\n\r\n  public error(message?: any | (() => any), ...additional: any[]): void {\r\n    this._log(NgxLoggerLevel.ERROR, message, additional);\r\n  }\r\n\r\n  public fatal(message?: any | (() => any), ...additional: any[]): void {\r\n    this._log(NgxLoggerLevel.FATAL, message, additional);\r\n  }\r\n\r\n  /** @deprecated customHttpHeaders is now part of the config, this should be updated via @see updateConfig */\r\n  public setCustomHttpHeaders(headers: HttpHeaders) {\r\n    const config = this.getConfigSnapshot();\r\n    config.customHttpHeaders = headers;\r\n    this.updateConfig(config);\r\n  }\r\n\r\n  /** @deprecated customHttpParams is now part of the config, this should be updated via @see updateConfig */\r\n  public setCustomParams(params: HttpParams) {\r\n    const config = this.getConfigSnapshot();\r\n    config.customHttpParams = params;\r\n    this.updateConfig(config);\r\n  }\r\n\r\n  /** @deprecated withCredentials is now part of the config, this should be updated via @see updateConfig */\r\n  public setWithCredentialsOptionValue(withCredentials: boolean) {\r\n    const config = this.getConfigSnapshot();\r\n    config.withCredentials = withCredentials;\r\n    this.updateConfig(config);\r\n  }\r\n\r\n  /**\r\n   * Register a INGXLoggerMonitor that will be trigger when a log is either written or sent to server\r\n   * \r\n   * There is only one monitor, registering one will overwrite the last one if there was one\r\n   * @param monitor \r\n   */\r\n  public registerMonitor(monitor: INGXLoggerMonitor) {\r\n    this._loggerMonitor = monitor;\r\n  }\r\n\r\n  /** Set config of logger\r\n   * \r\n   * Warning : This overwrites all the config, if you want to update only one property, you should use @see getConfigSnapshot before\r\n   */\r\n  public updateConfig(config: INGXLoggerConfig) {\r\n    this.configEngine.updateConfig(config);\r\n  }\r\n\r\n  /** Get config of logger */\r\n  public getConfigSnapshot(): INGXLoggerConfig {\r\n    return this.configEngine.getConfig();\r\n  }\r\n\r\n  private _log(level: NgxLoggerLevel, message?: any | (() => any), additional: any[] = []): void {\r\n    const config = this.configEngine.getConfig();\r\n\r\n    const shouldCallWriter = this.ruleService.shouldCallWriter(level, config, message, additional);\r\n    const shouldCallServer = this.ruleService.shouldCallServer(level, config, message, additional);\r\n    const shouldCallMonitor = this.ruleService.shouldCallMonitor(level, config, message, additional);\r\n\r\n    if (!shouldCallWriter && !shouldCallServer && !shouldCallMonitor) {\r\n      // If nothing is to be called we return\r\n      return;\r\n    }\r\n\r\n    const metadata = this.metadataService.getMetadata(level, config, message, additional);\r\n    this.mapperService.getLogPosition(config, metadata).pipe(take(1)).subscribe(logPosition => {\r\n      if (logPosition) {\r\n        metadata.fileName = logPosition.fileName;\r\n        metadata.lineNumber = logPosition.lineNumber;\r\n        metadata.columnNumber = logPosition.columnNumber;\r\n      }\r\n\r\n      if (shouldCallMonitor && this._loggerMonitor) {\r\n        this._loggerMonitor.onLog(metadata, config);\r\n      }\r\n      if (shouldCallWriter) {\r\n        this.writerService.writeMessage(metadata, config);\r\n      }\r\n      if (shouldCallServer) {\r\n        this.serverService.sendToServer(metadata, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n","import { Inject, Injectable } from '@angular/core';\r\nimport { INGXLoggerConfig } from './config/iconfig';\r\nimport { NGXLogger } from './logger.service';\r\nimport { TOKEN_LOGGER_MAPPER_SERVICE, INGXLoggerMapperService } from './mapper/imapper.service';\r\nimport { TOKEN_LOGGER_METADATA_SERVICE, INGXLoggerMetadataService } from './metadata/imetadata.service';\r\nimport { TOKEN_LOGGER_RULES_SERVICE, INGXLoggerRulesService } from './rules/irules.service';\r\nimport { TOKEN_LOGGER_SERVER_SERVICE, INGXLoggerServerService } from './server/iserver.service';\r\nimport { TOKEN_LOGGER_WRITER_SERVICE, INGXLoggerWriterService } from './writer/iwriter.service';\r\nimport { INGXLoggerMonitor } from './monitor/ilogger-monitor';\r\nimport { INGXLoggerConfigEngineFactory, TOKEN_LOGGER_CONFIG_ENGINE_FACTORY } from './config/iconfig-engine-factory';\r\n\r\n// Keeping this to avoid any breaking change for now, this class should be removed later\r\n\r\n/**\r\n * CustomNGXLoggerService is designed to allow users to get a new instance of a logger\r\n * @deprecated The logger is now fully customisable so this class is now useless\r\n */\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class CustomNGXLoggerService {\r\n\r\n  constructor(\r\n    @Inject(TOKEN_LOGGER_CONFIG_ENGINE_FACTORY) private configEngineFactory: INGXLoggerConfigEngineFactory,\r\n    @Inject(TOKEN_LOGGER_METADATA_SERVICE) private metadataService: INGXLoggerMetadataService,\r\n    @Inject(TOKEN_LOGGER_RULES_SERVICE) private ruleService: INGXLoggerRulesService,\r\n    @Inject(TOKEN_LOGGER_MAPPER_SERVICE) private mapperService: INGXLoggerMapperService,\r\n    @Inject(TOKEN_LOGGER_WRITER_SERVICE) private writerService: INGXLoggerWriterService,\r\n    @Inject(TOKEN_LOGGER_SERVER_SERVICE) private serverService: INGXLoggerServerService,\r\n  ) { }\r\n\r\n\r\n  /**\r\n   * Create an instance of a logger\r\n   * @deprecated The logger is now fully customisable so this function is now useless, if you want a specific instance of NGXLogger, either use the new keyword or Angular dependency injection\r\n   * @param config \r\n   * @param serverService \r\n   * @param logMonitor \r\n   * @param mapperService \r\n   * @returns \r\n   */\r\n  create(\r\n    config: INGXLoggerConfig,\r\n    serverService?: INGXLoggerServerService,\r\n    logMonitor?: INGXLoggerMonitor,\r\n    mapperService?: INGXLoggerMapperService,\r\n  ): NGXLogger {\r\n    const logger = new NGXLogger(config, this.configEngineFactory, this.metadataService, this.ruleService, mapperService || this.mapperService, this.writerService, serverService || this.serverService);\r\n\r\n    if (logMonitor) {\r\n      logger.registerMonitor(logMonitor);\r\n    }\r\n\r\n    return logger;\r\n  }\r\n}\r\n\r\n\r\n","import { CommonModule } from '@angular/common';\r\nimport { ClassProvider, ConstructorProvider, ExistingProvider, FactoryProvider, ModuleWithProviders, NgModule, ValueProvider } from '@angular/core';\r\n\r\nimport { NGXLogger } from './logger.service';\r\nimport { CustomNGXLoggerService } from './custom-logger.service';\r\nimport { INGXLoggerConfig, TOKEN_LOGGER_CONFIG } from './config/iconfig';\r\nimport { NGXLoggerMapperService } from './mapper/mapper.service';\r\nimport { TOKEN_LOGGER_METADATA_SERVICE } from './metadata/imetadata.service';\r\nimport { NGXLoggerMetadataService } from './metadata/metadata.service';\r\nimport { TOKEN_LOGGER_RULES_SERVICE } from './rules/irules.service';\r\nimport { NGXLoggerRulesService } from './rules/rules.service';\r\nimport { TOKEN_LOGGER_MAPPER_SERVICE } from './mapper/imapper.service';\r\nimport { NGXLoggerWriterService } from './writer/writer.service';\r\nimport { TOKEN_LOGGER_WRITER_SERVICE } from './writer/iwriter.service';\r\nimport { NGXLoggerServerService } from './server/server.service';\r\nimport { TOKEN_LOGGER_SERVER_SERVICE } from './server/iserver.service';\r\nimport { NGXLoggerConfigEngineFactory } from './config/config-engine-factory';\r\nimport { TOKEN_LOGGER_CONFIG_ENGINE_FACTORY } from './config/iconfig-engine-factory';\r\n\r\n@NgModule({\r\n  imports: [\r\n    CommonModule\r\n  ],\r\n})\r\nexport class LoggerModule {\r\n  static forRoot(\r\n    config: INGXLoggerConfig | null | undefined,\r\n    customProvider?: {\r\n      configProvider?: ValueProvider | ClassProvider | ConstructorProvider | ExistingProvider | FactoryProvider,\r\n      configEngineFactoryProvider?: ValueProvider | ClassProvider | ConstructorProvider | ExistingProvider | FactoryProvider,\r\n      metadataProvider?: ValueProvider | ClassProvider | ConstructorProvider | ExistingProvider | FactoryProvider,\r\n      ruleProvider?: ValueProvider | ClassProvider | ConstructorProvider | ExistingProvider | FactoryProvider,\r\n      mapperProvider?: ValueProvider | ClassProvider | ConstructorProvider | ExistingProvider | FactoryProvider,\r\n      writerProvider?: ValueProvider | ClassProvider | ConstructorProvider | ExistingProvider | FactoryProvider,\r\n      serverProvider?: ValueProvider | ClassProvider | ConstructorProvider | ExistingProvider | FactoryProvider,\r\n    }\r\n  ): ModuleWithProviders<LoggerModule> {\r\n    if (!customProvider) {\r\n      customProvider = {}\r\n    }\r\n\r\n    // default config provider\r\n    if (!customProvider.configProvider) {\r\n      customProvider.configProvider = { provide: TOKEN_LOGGER_CONFIG, useValue: config || {} };\r\n    } else {\r\n      // if the user provided its own config, we just make sure the injection token is correct\r\n      if (customProvider.configProvider.provide !== TOKEN_LOGGER_CONFIG) {\r\n        throw new Error(`Wrong injection token for configProvider, it should be ${TOKEN_LOGGER_CONFIG} and you used ${customProvider.configProvider.provide}`);\r\n      }\r\n    }\r\n\r\n    // default configEngine provider\r\n    if (!customProvider.configEngineFactoryProvider) {\r\n      customProvider.configEngineFactoryProvider = { provide: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, useClass: NGXLoggerConfigEngineFactory };\r\n    } else {\r\n      // if the user provided its own configEngineFactory, we just make sure the injection token is correct\r\n      if (customProvider.configEngineFactoryProvider.provide !== TOKEN_LOGGER_CONFIG_ENGINE_FACTORY) {\r\n        throw new Error(`Wrong injection token for configEngineFactoryProvider, it should be '${TOKEN_LOGGER_CONFIG_ENGINE_FACTORY}' and you used '${customProvider.configEngineFactoryProvider.provide}'`);\r\n      }\r\n    }\r\n\r\n    // default metadata provider\r\n    if (!customProvider.metadataProvider) {\r\n      customProvider.metadataProvider = { provide: TOKEN_LOGGER_METADATA_SERVICE, useClass: NGXLoggerMetadataService };\r\n    } else {\r\n      // if the user provided its own metadataService, we just make sure the injection token is correct\r\n      if (customProvider.metadataProvider.provide !== TOKEN_LOGGER_METADATA_SERVICE) {\r\n        throw new Error(`Wrong injection token for metadataProvider, it should be '${TOKEN_LOGGER_METADATA_SERVICE}' and you used '${customProvider.metadataProvider.provide}'`);\r\n      }\r\n    }\r\n\r\n    // default rule provider\r\n    if (!customProvider.ruleProvider) {\r\n      customProvider.ruleProvider = { provide: TOKEN_LOGGER_RULES_SERVICE, useClass: NGXLoggerRulesService };\r\n    } else {\r\n      // if the user provided its own ruleService, we just make sure the injection token is correct\r\n      if (customProvider.ruleProvider.provide !== TOKEN_LOGGER_RULES_SERVICE) {\r\n        throw new Error(`Wrong injection token for ruleProvider, it should be '${TOKEN_LOGGER_RULES_SERVICE}' and you used '${customProvider.ruleProvider.provide}'`);\r\n      }\r\n    }\r\n\r\n    // default mapper provider\r\n    if (!customProvider.mapperProvider) {\r\n      customProvider.mapperProvider = { provide: TOKEN_LOGGER_MAPPER_SERVICE, useClass: NGXLoggerMapperService };\r\n    } else {\r\n      // if the user provided its own mapperService, we just make sure the injection token is correct\r\n      if (customProvider.mapperProvider.provide !== TOKEN_LOGGER_MAPPER_SERVICE) {\r\n        throw new Error(`Wrong injection token for mapperProvider, it should be '${TOKEN_LOGGER_MAPPER_SERVICE}' and you used '${customProvider.mapperProvider.provide}'`);\r\n      }\r\n    }\r\n\r\n    // default writer provider\r\n    if (!customProvider.writerProvider) {\r\n      customProvider.writerProvider = { provide: TOKEN_LOGGER_WRITER_SERVICE, useClass: NGXLoggerWriterService };\r\n    } else {\r\n      // if the user provided its own writerService, we just make sure the injection token is correct\r\n      if (customProvider.writerProvider.provide !== TOKEN_LOGGER_WRITER_SERVICE) {\r\n        throw new Error(`Wrong injection token for writerProvider, it should be '${TOKEN_LOGGER_WRITER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\r\n      }\r\n    }\r\n\r\n    // default server provider\r\n    if (!customProvider.serverProvider) {\r\n      customProvider.serverProvider = { provide: TOKEN_LOGGER_SERVER_SERVICE, useClass: NGXLoggerServerService };\r\n    } else {\r\n      // if the user provided its own serverService, we just make sure the injection token is correct\r\n      if (customProvider.serverProvider.provide !== TOKEN_LOGGER_SERVER_SERVICE) {\r\n        throw new Error(`Wrong injection token for serverProvider, it should be '${TOKEN_LOGGER_SERVER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\r\n      }\r\n    }\r\n\r\n    return {\r\n      ngModule: LoggerModule,\r\n      providers: [\r\n        NGXLogger,\r\n        customProvider.configProvider,\r\n        customProvider.configEngineFactoryProvider,\r\n        customProvider.metadataProvider,\r\n        customProvider.ruleProvider,\r\n        customProvider.mapperProvider,\r\n        customProvider.writerProvider,\r\n        customProvider.serverProvider,\r\n        CustomNGXLoggerService,\r\n      ]\r\n    };\r\n  }\r\n\r\n  static forChild(): ModuleWithProviders<LoggerModule> {\r\n    // todo : this forChild is useless for now because nothing is different from forRoot.\r\n    // This should be implemented so that user can change the providers in the forChild\r\n    return {\r\n      ngModule: LoggerModule,\r\n    };\r\n  }\r\n}\r\n"]}