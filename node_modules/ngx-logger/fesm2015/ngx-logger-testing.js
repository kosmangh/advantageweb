import { ɵɵdefineInjectable, ɵsetClassMetadata, Injectable, ɵɵdefineNgModule, ɵɵdefineInjector, ɵɵsetNgModuleScope, NgModule } from '@angular/core';
import { NgxLoggerLevel, NGXLogger, TOKEN_LOGGER_CONFIG, TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, TOKEN_LOGGER_METADATA_SERVICE, TOKEN_LOGGER_RULES_SERVICE, TOKEN_LOGGER_MAPPER_SERVICE, TOKEN_LOGGER_WRITER_SERVICE, TOKEN_LOGGER_SERVER_SERVICE, CustomNGXLoggerService, LoggerModule } from 'ngx-logger';
import { of } from 'rxjs';

class NGXLoggerConfigEngineMock {
    get level() {
        return NgxLoggerLevel.ERROR;
    }
    get serverLogLevel() {
        return NgxLoggerLevel.OFF;
    }
    updateConfig(config) {
    }
    getConfig() {
        return { level: NgxLoggerLevel.ERROR };
    }
}
/** @nocollapse */ NGXLoggerConfigEngineMock.ɵfac = function NGXLoggerConfigEngineMock_Factory(t) { return new (t || NGXLoggerConfigEngineMock)(); };
/** @nocollapse */ NGXLoggerConfigEngineMock.ɵprov = ɵɵdefineInjectable({ token: NGXLoggerConfigEngineMock, factory: NGXLoggerConfigEngineMock.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassMetadata(NGXLoggerConfigEngineMock, [{
        type: Injectable
    }], null, null); })();

// todo bmtheo, there should be an interface or something to make sure this mock sticks to the real API
class NGXLoggerMock {
    get level() {
        return NgxLoggerLevel.ERROR;
    }
    get serverLogLevel() {
        return NgxLoggerLevel.OFF;
    }
    trace(message, ...additional) {
    }
    debug(message, ...additional) {
    }
    info(message, ...additional) {
    }
    log(message, ...additional) {
    }
    warn(message, ...additional) {
    }
    error(message, ...additional) {
    }
    fatal(message, ...additional) {
    }
    updateConfig(config) {
    }
    setCustomHttpHeaders(headers) {
    }
    setCustomParams(params) {
    }
    registerMonitor(monitor) {
    }
    setWithCredentialsOptionValue(withCredentials) {
    }
    getConfigSnapshot() {
        return { level: NgxLoggerLevel.ERROR };
    }
}
/** @nocollapse */ NGXLoggerMock.ɵfac = function NGXLoggerMock_Factory(t) { return new (t || NGXLoggerMock)(); };
/** @nocollapse */ NGXLoggerMock.ɵprov = ɵɵdefineInjectable({ token: NGXLoggerMock, factory: NGXLoggerMock.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassMetadata(NGXLoggerMock, [{
        type: Injectable
    }], null, null); })();

/**
 * CustomNGXLoggerServiceMock is a mock for CustomNGXLoggerService
 */
class CustomNGXLoggerServiceMock {
    create() {
        return new NGXLoggerMock();
    }
}
/** @nocollapse */ CustomNGXLoggerServiceMock.ɵfac = function CustomNGXLoggerServiceMock_Factory(t) { return new (t || CustomNGXLoggerServiceMock)(); };
/** @nocollapse */ CustomNGXLoggerServiceMock.ɵprov = ɵɵdefineInjectable({ token: CustomNGXLoggerServiceMock, factory: CustomNGXLoggerServiceMock.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassMetadata(CustomNGXLoggerServiceMock, [{
        type: Injectable
    }], null, null); })();

class NGXLoggerConfigEngineFactoryMock {
    provideConfigEngine(config) {
        return new NGXLoggerConfigEngineMock();
    }
}
/** @nocollapse */ NGXLoggerConfigEngineFactoryMock.ɵfac = function NGXLoggerConfigEngineFactoryMock_Factory(t) { return new (t || NGXLoggerConfigEngineFactoryMock)(); };
/** @nocollapse */ NGXLoggerConfigEngineFactoryMock.ɵprov = ɵɵdefineInjectable({ token: NGXLoggerConfigEngineFactoryMock, factory: NGXLoggerConfigEngineFactoryMock.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassMetadata(NGXLoggerConfigEngineFactoryMock, [{
        type: Injectable
    }], null, null); })();

class NGXLoggerMapperServiceMock {
    getLogPosition(config, metadata) {
        return of({ fileName: 'test.ts' });
    }
}
/** @nocollapse */ NGXLoggerMapperServiceMock.ɵfac = function NGXLoggerMapperServiceMock_Factory(t) { return new (t || NGXLoggerMapperServiceMock)(); };
/** @nocollapse */ NGXLoggerMapperServiceMock.ɵprov = ɵɵdefineInjectable({ token: NGXLoggerMapperServiceMock, factory: NGXLoggerMapperServiceMock.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassMetadata(NGXLoggerMapperServiceMock, [{
        type: Injectable
    }], null, null); })();

class NGXLoggerMetadataServiceMock {
    getMetadata(level, config, message, additional) {
        return {
            level: level
        };
    }
}
/** @nocollapse */ NGXLoggerMetadataServiceMock.ɵfac = function NGXLoggerMetadataServiceMock_Factory(t) { return new (t || NGXLoggerMetadataServiceMock)(); };
/** @nocollapse */ NGXLoggerMetadataServiceMock.ɵprov = ɵɵdefineInjectable({ token: NGXLoggerMetadataServiceMock, factory: NGXLoggerMetadataServiceMock.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassMetadata(NGXLoggerMetadataServiceMock, [{
        type: Injectable
    }], null, null); })();

class NGXLoggerRulesServiceMock {
    shouldCallWriter(level, config, message, additional) {
        return false;
    }
    shouldCallServer(level, config, message, additional) {
        return false;
    }
    shouldCallMonitor(level, config, message, additional) {
        return false;
    }
}
/** @nocollapse */ NGXLoggerRulesServiceMock.ɵfac = function NGXLoggerRulesServiceMock_Factory(t) { return new (t || NGXLoggerRulesServiceMock)(); };
/** @nocollapse */ NGXLoggerRulesServiceMock.ɵprov = ɵɵdefineInjectable({ token: NGXLoggerRulesServiceMock, factory: NGXLoggerRulesServiceMock.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassMetadata(NGXLoggerRulesServiceMock, [{
        type: Injectable
    }], null, null); })();

class NGXLoggerServerServiceMock {
    sendToServer(metadata, config) {
    }
}
/** @nocollapse */ NGXLoggerServerServiceMock.ɵfac = function NGXLoggerServerServiceMock_Factory(t) { return new (t || NGXLoggerServerServiceMock)(); };
/** @nocollapse */ NGXLoggerServerServiceMock.ɵprov = ɵɵdefineInjectable({ token: NGXLoggerServerServiceMock, factory: NGXLoggerServerServiceMock.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassMetadata(NGXLoggerServerServiceMock, [{
        type: Injectable
    }], null, null); })();

class NGXLoggerWriterServiceMock {
    writeMessage(metadata, config) {
    }
}
/** @nocollapse */ NGXLoggerWriterServiceMock.ɵfac = function NGXLoggerWriterServiceMock_Factory(t) { return new (t || NGXLoggerWriterServiceMock)(); };
/** @nocollapse */ NGXLoggerWriterServiceMock.ɵprov = ɵɵdefineInjectable({ token: NGXLoggerWriterServiceMock, factory: NGXLoggerWriterServiceMock.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassMetadata(NGXLoggerWriterServiceMock, [{
        type: Injectable
    }], null, null); })();

class LoggerTestingModule {
}
/** @nocollapse */ LoggerTestingModule.ɵfac = function LoggerTestingModule_Factory(t) { return new (t || LoggerTestingModule)(); };
/** @nocollapse */ LoggerTestingModule.ɵmod = ɵɵdefineNgModule({ type: LoggerTestingModule });
/** @nocollapse */ LoggerTestingModule.ɵinj = ɵɵdefineInjector({ providers: [
        { provide: NGXLogger, useClass: NGXLoggerMock },
        { provide: TOKEN_LOGGER_CONFIG, useValue: { level: NgxLoggerLevel.ERROR } },
        { provide: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, useClass: NGXLoggerConfigEngineFactoryMock },
        { provide: TOKEN_LOGGER_METADATA_SERVICE, useClass: NGXLoggerMetadataServiceMock },
        { provide: TOKEN_LOGGER_RULES_SERVICE, useClass: NGXLoggerRulesServiceMock },
        { provide: TOKEN_LOGGER_MAPPER_SERVICE, useClass: NGXLoggerMapperServiceMock },
        { provide: TOKEN_LOGGER_WRITER_SERVICE, useClass: NGXLoggerWriterServiceMock },
        { provide: TOKEN_LOGGER_SERVER_SERVICE, useClass: NGXLoggerServerServiceMock },
        { provide: CustomNGXLoggerService, useClass: CustomNGXLoggerServiceMock },
    ], imports: [[LoggerModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(LoggerTestingModule, { imports: [LoggerModule] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵsetClassMetadata(LoggerTestingModule, [{
        type: NgModule,
        args: [{
                imports: [LoggerModule],
                providers: [
                    { provide: NGXLogger, useClass: NGXLoggerMock },
                    { provide: TOKEN_LOGGER_CONFIG, useValue: { level: NgxLoggerLevel.ERROR } },
                    { provide: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, useClass: NGXLoggerConfigEngineFactoryMock },
                    { provide: TOKEN_LOGGER_METADATA_SERVICE, useClass: NGXLoggerMetadataServiceMock },
                    { provide: TOKEN_LOGGER_RULES_SERVICE, useClass: NGXLoggerRulesServiceMock },
                    { provide: TOKEN_LOGGER_MAPPER_SERVICE, useClass: NGXLoggerMapperServiceMock },
                    { provide: TOKEN_LOGGER_WRITER_SERVICE, useClass: NGXLoggerWriterServiceMock },
                    { provide: TOKEN_LOGGER_SERVER_SERVICE, useClass: NGXLoggerServerServiceMock },
                    { provide: CustomNGXLoggerService, useClass: CustomNGXLoggerServiceMock },
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { CustomNGXLoggerServiceMock, LoggerTestingModule, NGXLoggerConfigEngineFactoryMock, NGXLoggerConfigEngineMock, NGXLoggerMapperServiceMock, NGXLoggerMetadataServiceMock, NGXLoggerMock, NGXLoggerRulesServiceMock, NGXLoggerServerServiceMock, NGXLoggerWriterServiceMock };
//# sourceMappingURL=ngx-logger-testing.js.map
