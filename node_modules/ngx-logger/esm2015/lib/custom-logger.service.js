import { Inject, Injectable } from '@angular/core';
import { NGXLogger } from './logger.service';
import { TOKEN_LOGGER_MAPPER_SERVICE } from './mapper/imapper.service';
import { TOKEN_LOGGER_METADATA_SERVICE } from './metadata/imetadata.service';
import { TOKEN_LOGGER_RULES_SERVICE } from './rules/irules.service';
import { TOKEN_LOGGER_SERVER_SERVICE } from './server/iserver.service';
import { TOKEN_LOGGER_WRITER_SERVICE } from './writer/iwriter.service';
import { TOKEN_LOGGER_CONFIG_ENGINE_FACTORY } from './config/iconfig-engine-factory';
import * as i0 from "@angular/core";
// Keeping this to avoid any breaking change for now, this class should be removed later
/**
 * CustomNGXLoggerService is designed to allow users to get a new instance of a logger
 * @deprecated The logger is now fully customisable so this class is now useless
 */
export class CustomNGXLoggerService {
    constructor(configEngineFactory, metadataService, ruleService, mapperService, writerService, serverService) {
        this.configEngineFactory = configEngineFactory;
        this.metadataService = metadataService;
        this.ruleService = ruleService;
        this.mapperService = mapperService;
        this.writerService = writerService;
        this.serverService = serverService;
    }
    /**
     * Create an instance of a logger
     * @deprecated The logger is now fully customisable so this function is now useless, if you want a specific instance of NGXLogger, either use the new keyword or Angular dependency injection
     * @param config
     * @param serverService
     * @param logMonitor
     * @param mapperService
     * @returns
     */
    create(config, serverService, logMonitor, mapperService) {
        const logger = new NGXLogger(config, this.configEngineFactory, this.metadataService, this.ruleService, mapperService || this.mapperService, this.writerService, serverService || this.serverService);
        if (logMonitor) {
            logger.registerMonitor(logMonitor);
        }
        return logger;
    }
}
/** @nocollapse */ CustomNGXLoggerService.ɵfac = function CustomNGXLoggerService_Factory(t) { return new (t || CustomNGXLoggerService)(i0.ɵɵinject(TOKEN_LOGGER_CONFIG_ENGINE_FACTORY), i0.ɵɵinject(TOKEN_LOGGER_METADATA_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_RULES_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_MAPPER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_WRITER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_SERVER_SERVICE)); };
/** @nocollapse */ CustomNGXLoggerService.ɵprov = i0.ɵɵdefineInjectable({ token: CustomNGXLoggerService, factory: CustomNGXLoggerService.ɵfac, providedIn: 'root' });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(CustomNGXLoggerService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [TOKEN_LOGGER_CONFIG_ENGINE_FACTORY]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [TOKEN_LOGGER_METADATA_SERVICE]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [TOKEN_LOGGER_RULES_SERVICE]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [TOKEN_LOGGER_MAPPER_SERVICE]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [TOKEN_LOGGER_WRITER_SERVICE]
            }] }, { type: undefined, decorators: [{
                type: Inject,
                args: [TOKEN_LOGGER_SERVER_SERVICE]
            }] }]; }, null); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3VzdG9tLWxvZ2dlci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2xpYi9jdXN0b20tbG9nZ2VyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFbkQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQzdDLE9BQU8sRUFBRSwyQkFBMkIsRUFBMkIsTUFBTSwwQkFBMEIsQ0FBQztBQUNoRyxPQUFPLEVBQUUsNkJBQTZCLEVBQTZCLE1BQU0sOEJBQThCLENBQUM7QUFDeEcsT0FBTyxFQUFFLDBCQUEwQixFQUEwQixNQUFNLHdCQUF3QixDQUFDO0FBQzVGLE9BQU8sRUFBRSwyQkFBMkIsRUFBMkIsTUFBTSwwQkFBMEIsQ0FBQztBQUNoRyxPQUFPLEVBQUUsMkJBQTJCLEVBQTJCLE1BQU0sMEJBQTBCLENBQUM7QUFFaEcsT0FBTyxFQUFpQyxrQ0FBa0MsRUFBRSxNQUFNLGlDQUFpQyxDQUFDOztBQUVwSCx3RkFBd0Y7QUFFeEY7OztHQUdHO0FBSUgsTUFBTSxPQUFPLHNCQUFzQjtJQUVqQyxZQUNzRCxtQkFBa0QsRUFDdkQsZUFBMEMsRUFDN0MsV0FBbUMsRUFDbEMsYUFBc0MsRUFDdEMsYUFBc0MsRUFDdEMsYUFBc0M7UUFML0Isd0JBQW1CLEdBQW5CLG1CQUFtQixDQUErQjtRQUN2RCxvQkFBZSxHQUFmLGVBQWUsQ0FBMkI7UUFDN0MsZ0JBQVcsR0FBWCxXQUFXLENBQXdCO1FBQ2xDLGtCQUFhLEdBQWIsYUFBYSxDQUF5QjtRQUN0QyxrQkFBYSxHQUFiLGFBQWEsQ0FBeUI7UUFDdEMsa0JBQWEsR0FBYixhQUFhLENBQXlCO0lBQ2pGLENBQUM7SUFHTDs7Ozs7Ozs7T0FRRztJQUNILE1BQU0sQ0FDSixNQUF3QixFQUN4QixhQUF1QyxFQUN2QyxVQUE4QixFQUM5QixhQUF1QztRQUV2QyxNQUFNLE1BQU0sR0FBRyxJQUFJLFNBQVMsQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLG1CQUFtQixFQUFFLElBQUksQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLFdBQVcsRUFBRSxhQUFhLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRSxJQUFJLENBQUMsYUFBYSxFQUFFLGFBQWEsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFck0sSUFBSSxVQUFVLEVBQUU7WUFDZCxNQUFNLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQ3BDO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQzs7K0dBbENVLHNCQUFzQixjQUd2QixrQ0FBa0MsZUFDbEMsNkJBQTZCLGVBQzdCLDBCQUEwQixlQUMxQiwyQkFBMkIsZUFDM0IsMkJBQTJCLGVBQzNCLDJCQUEyQjtpRkFSMUIsc0JBQXNCLFdBQXRCLHNCQUFzQixtQkFGckIsTUFBTTt1RkFFUCxzQkFBc0I7Y0FIbEMsVUFBVTtlQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COztzQkFJSSxNQUFNO3VCQUFDLGtDQUFrQzs7c0JBQ3pDLE1BQU07dUJBQUMsNkJBQTZCOztzQkFDcEMsTUFBTTt1QkFBQywwQkFBMEI7O3NCQUNqQyxNQUFNO3VCQUFDLDJCQUEyQjs7c0JBQ2xDLE1BQU07dUJBQUMsMkJBQTJCOztzQkFDbEMsTUFBTTt1QkFBQywyQkFBMkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgSU5HWExvZ2dlckNvbmZpZyB9IGZyb20gJy4vY29uZmlnL2ljb25maWcnO1xyXG5pbXBvcnQgeyBOR1hMb2dnZXIgfSBmcm9tICcuL2xvZ2dlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgVE9LRU5fTE9HR0VSX01BUFBFUl9TRVJWSUNFLCBJTkdYTG9nZ2VyTWFwcGVyU2VydmljZSB9IGZyb20gJy4vbWFwcGVyL2ltYXBwZXIuc2VydmljZSc7XHJcbmltcG9ydCB7IFRPS0VOX0xPR0dFUl9NRVRBREFUQV9TRVJWSUNFLCBJTkdYTG9nZ2VyTWV0YWRhdGFTZXJ2aWNlIH0gZnJvbSAnLi9tZXRhZGF0YS9pbWV0YWRhdGEuc2VydmljZSc7XHJcbmltcG9ydCB7IFRPS0VOX0xPR0dFUl9SVUxFU19TRVJWSUNFLCBJTkdYTG9nZ2VyUnVsZXNTZXJ2aWNlIH0gZnJvbSAnLi9ydWxlcy9pcnVsZXMuc2VydmljZSc7XHJcbmltcG9ydCB7IFRPS0VOX0xPR0dFUl9TRVJWRVJfU0VSVklDRSwgSU5HWExvZ2dlclNlcnZlclNlcnZpY2UgfSBmcm9tICcuL3NlcnZlci9pc2VydmVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBUT0tFTl9MT0dHRVJfV1JJVEVSX1NFUlZJQ0UsIElOR1hMb2dnZXJXcml0ZXJTZXJ2aWNlIH0gZnJvbSAnLi93cml0ZXIvaXdyaXRlci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSU5HWExvZ2dlck1vbml0b3IgfSBmcm9tICcuL21vbml0b3IvaWxvZ2dlci1tb25pdG9yJztcclxuaW1wb3J0IHsgSU5HWExvZ2dlckNvbmZpZ0VuZ2luZUZhY3RvcnksIFRPS0VOX0xPR0dFUl9DT05GSUdfRU5HSU5FX0ZBQ1RPUlkgfSBmcm9tICcuL2NvbmZpZy9pY29uZmlnLWVuZ2luZS1mYWN0b3J5JztcclxuXHJcbi8vIEtlZXBpbmcgdGhpcyB0byBhdm9pZCBhbnkgYnJlYWtpbmcgY2hhbmdlIGZvciBub3csIHRoaXMgY2xhc3Mgc2hvdWxkIGJlIHJlbW92ZWQgbGF0ZXJcclxuXHJcbi8qKlxyXG4gKiBDdXN0b21OR1hMb2dnZXJTZXJ2aWNlIGlzIGRlc2lnbmVkIHRvIGFsbG93IHVzZXJzIHRvIGdldCBhIG5ldyBpbnN0YW5jZSBvZiBhIGxvZ2dlclxyXG4gKiBAZGVwcmVjYXRlZCBUaGUgbG9nZ2VyIGlzIG5vdyBmdWxseSBjdXN0b21pc2FibGUgc28gdGhpcyBjbGFzcyBpcyBub3cgdXNlbGVzc1xyXG4gKi9cclxuQEluamVjdGFibGUoe1xyXG4gIHByb3ZpZGVkSW46ICdyb290J1xyXG59KVxyXG5leHBvcnQgY2xhc3MgQ3VzdG9tTkdYTG9nZ2VyU2VydmljZSB7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgQEluamVjdChUT0tFTl9MT0dHRVJfQ09ORklHX0VOR0lORV9GQUNUT1JZKSBwcml2YXRlIGNvbmZpZ0VuZ2luZUZhY3Rvcnk6IElOR1hMb2dnZXJDb25maWdFbmdpbmVGYWN0b3J5LFxyXG4gICAgQEluamVjdChUT0tFTl9MT0dHRVJfTUVUQURBVEFfU0VSVklDRSkgcHJpdmF0ZSBtZXRhZGF0YVNlcnZpY2U6IElOR1hMb2dnZXJNZXRhZGF0YVNlcnZpY2UsXHJcbiAgICBASW5qZWN0KFRPS0VOX0xPR0dFUl9SVUxFU19TRVJWSUNFKSBwcml2YXRlIHJ1bGVTZXJ2aWNlOiBJTkdYTG9nZ2VyUnVsZXNTZXJ2aWNlLFxyXG4gICAgQEluamVjdChUT0tFTl9MT0dHRVJfTUFQUEVSX1NFUlZJQ0UpIHByaXZhdGUgbWFwcGVyU2VydmljZTogSU5HWExvZ2dlck1hcHBlclNlcnZpY2UsXHJcbiAgICBASW5qZWN0KFRPS0VOX0xPR0dFUl9XUklURVJfU0VSVklDRSkgcHJpdmF0ZSB3cml0ZXJTZXJ2aWNlOiBJTkdYTG9nZ2VyV3JpdGVyU2VydmljZSxcclxuICAgIEBJbmplY3QoVE9LRU5fTE9HR0VSX1NFUlZFUl9TRVJWSUNFKSBwcml2YXRlIHNlcnZlclNlcnZpY2U6IElOR1hMb2dnZXJTZXJ2ZXJTZXJ2aWNlLFxyXG4gICkgeyB9XHJcblxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgYSBsb2dnZXJcclxuICAgKiBAZGVwcmVjYXRlZCBUaGUgbG9nZ2VyIGlzIG5vdyBmdWxseSBjdXN0b21pc2FibGUgc28gdGhpcyBmdW5jdGlvbiBpcyBub3cgdXNlbGVzcywgaWYgeW91IHdhbnQgYSBzcGVjaWZpYyBpbnN0YW5jZSBvZiBOR1hMb2dnZXIsIGVpdGhlciB1c2UgdGhlIG5ldyBrZXl3b3JkIG9yIEFuZ3VsYXIgZGVwZW5kZW5jeSBpbmplY3Rpb25cclxuICAgKiBAcGFyYW0gY29uZmlnIFxyXG4gICAqIEBwYXJhbSBzZXJ2ZXJTZXJ2aWNlIFxyXG4gICAqIEBwYXJhbSBsb2dNb25pdG9yIFxyXG4gICAqIEBwYXJhbSBtYXBwZXJTZXJ2aWNlIFxyXG4gICAqIEByZXR1cm5zIFxyXG4gICAqL1xyXG4gIGNyZWF0ZShcclxuICAgIGNvbmZpZzogSU5HWExvZ2dlckNvbmZpZyxcclxuICAgIHNlcnZlclNlcnZpY2U/OiBJTkdYTG9nZ2VyU2VydmVyU2VydmljZSxcclxuICAgIGxvZ01vbml0b3I/OiBJTkdYTG9nZ2VyTW9uaXRvcixcclxuICAgIG1hcHBlclNlcnZpY2U/OiBJTkdYTG9nZ2VyTWFwcGVyU2VydmljZSxcclxuICApOiBOR1hMb2dnZXIge1xyXG4gICAgY29uc3QgbG9nZ2VyID0gbmV3IE5HWExvZ2dlcihjb25maWcsIHRoaXMuY29uZmlnRW5naW5lRmFjdG9yeSwgdGhpcy5tZXRhZGF0YVNlcnZpY2UsIHRoaXMucnVsZVNlcnZpY2UsIG1hcHBlclNlcnZpY2UgfHwgdGhpcy5tYXBwZXJTZXJ2aWNlLCB0aGlzLndyaXRlclNlcnZpY2UsIHNlcnZlclNlcnZpY2UgfHwgdGhpcy5zZXJ2ZXJTZXJ2aWNlKTtcclxuXHJcbiAgICBpZiAobG9nTW9uaXRvcikge1xyXG4gICAgICBsb2dnZXIucmVnaXN0ZXJNb25pdG9yKGxvZ01vbml0b3IpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsb2dnZXI7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuIl19