import { HttpHeaders, HttpParams, HttpRequest, HttpResponse } from '@angular/common/http';
import { Injectable, Optional } from '@angular/core';
import { of, throwError } from 'rxjs';
import { catchError, filter, map } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
export class NGXLoggerServerService {
    constructor(httpBackend) {
        this.httpBackend = httpBackend;
    }
    /**
     * Transforms an error object into a readable string (taking only the stack)
     * This is needed because JSON.stringify would return "{}"
     * @param err the error object
     * @returns The stack of the error
     */
    secureErrorObject(err) {
        return err === null || err === void 0 ? void 0 : err.stack;
    }
    /**
     * Transforms the additional parameters to avoid any json error when sending the data to the server
     * Basically it just replaces unstringifiable object to a string mentioning an error
     * @param additional The additional data to be sent
     * @returns The additional data secured
     */
    secureAdditionalParameters(additional) {
        if (additional === null || additional === undefined) {
            return null;
        }
        return additional.map((next, idx) => {
            try {
                if (next instanceof Error) {
                    return this.secureErrorObject(next);
                }
                // We just want to make sure the JSON can be parsed, we do not want to actually change the type
                if (typeof next === 'object') {
                    JSON.stringify(next);
                }
                return next;
            }
            catch (e) {
                return `The additional[${idx}] value could not be parsed using JSON.stringify().`;
            }
        });
    }
    /**
     * Transforms the message so that it can be sent to the server
     * @param message the message to be sent
     * @returns the message secured
     */
    secureMessage(message) {
        try {
            if (message instanceof Error) {
                return this.secureErrorObject(message);
            }
            if (typeof message !== 'string') {
                message = JSON.stringify(message, null, 2);
            }
        }
        catch (e) {
            message = 'The provided "message" value could not be parsed with JSON.stringify().';
        }
        return message;
    }
    logOnServer(url, logContent, options) {
        // HttpBackend skips all HttpInterceptors
        // They may log errors using this service causing circular calls
        const req = new HttpRequest('POST', url, logContent, options || {});
        if (!this.httpBackend) {
            console.error('NGXLogger : Can\'t log on server because HttpBackend is not provided. You need to import HttpClientModule');
            return of(null);
        }
        return this.httpBackend.handle(req).pipe(filter(e => e instanceof HttpResponse), map((httpResponse) => httpResponse.body));
    }
    /**
     * Customise the data sent to the API
     * @param metadata the data provided by NGXLogger
     * @returns the data that will be sent to the API in the body
     */
    customiseRequestBody(metadata) {
        // In our API the body is not customised
        return metadata;
    }
    sendToServer(metadata, config) {
        // Copying metadata locally because we don't want to change the object for the caller
        const localMetadata = Object.assign({}, metadata);
        localMetadata.additional = this.secureAdditionalParameters(localMetadata.additional);
        localMetadata.message = this.secureMessage(localMetadata.message);
        // Allow users to customise the data sent to the API
        const requestBody = this.customiseRequestBody(localMetadata);
        const headers = config.customHttpHeaders || new HttpHeaders();
        if (!headers.has('Content-Type')) {
            headers.set('Content-Type', 'application/json');
        }
        this.logOnServer(config.serverLoggingUrl, requestBody, {
            headers,
            params: config.customHttpParams || new HttpParams(),
            responseType: config.httpResponseType || 'json',
            withCredentials: config.withCredentials || false,
        }).pipe(catchError(err => {
            // Do not use NGXLogger here because this could cause an infinite loop 
            console.error('NGXLogger: Failed to log on server', err);
            return throwError(err);
        })).subscribe();
    }
}
/** @nocollapse */ NGXLoggerServerService.ɵfac = function NGXLoggerServerService_Factory(t) { return new (t || NGXLoggerServerService)(i0.ɵɵinject(i1.HttpBackend, 8)); };
/** @nocollapse */ NGXLoggerServerService.ɵprov = i0.ɵɵdefineInjectable({ token: NGXLoggerServerService, factory: NGXLoggerServerService.ɵfac });
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerServerService, [{
        type: Injectable
    }], function () { return [{ type: i1.HttpBackend, decorators: [{
                type: Optional
            }] }]; }, null); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VydmVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvbGliL3NlcnZlci9zZXJ2ZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQWUsV0FBVyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDdkcsT0FBTyxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckQsT0FBTyxFQUFjLEVBQUUsRUFBRSxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDbEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7OztBQU16RCxNQUFNLE9BQU8sc0JBQXNCO0lBRWpDLFlBQ2lDLFdBQXdCO1FBQXhCLGdCQUFXLEdBQVgsV0FBVyxDQUFhO0lBQ3JELENBQUM7SUFFTDs7Ozs7T0FLRztJQUNPLGlCQUFpQixDQUFDLEdBQVU7UUFDcEMsT0FBTyxHQUFHLGFBQUgsR0FBRyx1QkFBSCxHQUFHLENBQUUsS0FBSyxDQUFDO0lBQ3BCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNPLDBCQUEwQixDQUFDLFVBQWlCO1FBQ3BELElBQUksVUFBVSxLQUFLLElBQUksSUFBSSxVQUFVLEtBQUssU0FBUyxFQUFFO1lBQ25ELE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFFRCxPQUFPLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLEVBQUU7WUFDbEMsSUFBSTtnQkFDRixJQUFJLElBQUksWUFBWSxLQUFLLEVBQUU7b0JBQ3pCLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUNyQztnQkFDRCwrRkFBK0Y7Z0JBQy9GLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxFQUFFO29CQUM1QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO2lCQUN0QjtnQkFFRCxPQUFPLElBQUksQ0FBQzthQUNiO1lBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ1YsT0FBTyxrQkFBa0IsR0FBRyxxREFBcUQsQ0FBQzthQUNuRjtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7O09BSUc7SUFDTyxhQUFhLENBQUMsT0FBWTtRQUNsQyxJQUFJO1lBQ0YsSUFBSSxPQUFPLFlBQVksS0FBSyxFQUFFO2dCQUM1QixPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQzthQUN4QztZQUVELElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxFQUFFO2dCQUMvQixPQUFPLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO2FBQzVDO1NBQ0Y7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLE9BQU8sR0FBRyx5RUFBeUUsQ0FBQztTQUNyRjtRQUVELE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFUyxXQUFXLENBQ25CLEdBQVcsRUFDWCxVQUFhLEVBQ2IsT0FNQztRQUVELHlDQUF5QztRQUN6QyxnRUFBZ0U7UUFDaEUsTUFBTSxHQUFHLEdBQUcsSUFBSSxXQUFXLENBQUksTUFBTSxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsT0FBTyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBRXZFLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ3JCLE9BQU8sQ0FBQyxLQUFLLENBQUMsMkdBQTJHLENBQUMsQ0FBQztZQUMzSCxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNqQjtRQUNELE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUN0QyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFlBQVksWUFBWSxDQUFDLEVBQ3RDLEdBQUcsQ0FBcUIsQ0FBQyxZQUE2QixFQUFFLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQzlFLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNPLG9CQUFvQixDQUFDLFFBQTRCO1FBQ3pELHdDQUF3QztRQUN4QyxPQUFPLFFBQVEsQ0FBQztJQUNsQixDQUFDO0lBRU0sWUFBWSxDQUFDLFFBQTRCLEVBQUUsTUFBd0I7UUFDeEUscUZBQXFGO1FBQ3JGLE1BQU0sYUFBYSxxQkFBUSxRQUFRLENBQUUsQ0FBQztRQUV0QyxhQUFhLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQywwQkFBMEIsQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFckYsYUFBYSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUVsRSxvREFBb0Q7UUFDcEQsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBRTdELE1BQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxpQkFBaUIsSUFBSSxJQUFJLFdBQVcsRUFBRSxDQUFDO1FBQzlELElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxFQUFFO1lBQ2hDLE9BQU8sQ0FBQyxHQUFHLENBQUMsY0FBYyxFQUFFLGtCQUFrQixDQUFDLENBQUM7U0FDakQ7UUFFRCxJQUFJLENBQUMsV0FBVyxDQUFNLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxXQUFXLEVBQUU7WUFDMUQsT0FBTztZQUNQLE1BQU0sRUFBRSxNQUFNLENBQUMsZ0JBQWdCLElBQUksSUFBSSxVQUFVLEVBQUU7WUFDbkQsWUFBWSxFQUFFLE1BQU0sQ0FBQyxnQkFBZ0IsSUFBSSxNQUFNO1lBQy9DLGVBQWUsRUFBRSxNQUFNLENBQUMsZUFBZSxJQUFJLEtBQUs7U0FDakQsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDdkIsdUVBQXVFO1lBQ3ZFLE9BQU8sQ0FBQyxLQUFLLENBQUMsb0NBQW9DLEVBQUUsR0FBRyxDQUFDLENBQUM7WUFDekQsT0FBTyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDekIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUNsQixDQUFDOzsrR0E5SFUsc0JBQXNCO2lGQUF0QixzQkFBc0IsV0FBdEIsc0JBQXNCO3VGQUF0QixzQkFBc0I7Y0FEbEMsVUFBVTs7c0JBSU4sUUFBUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEh0dHBCYWNrZW5kLCBIdHRwSGVhZGVycywgSHR0cFBhcmFtcywgSHR0cFJlcXVlc3QsIEh0dHBSZXNwb25zZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcclxuaW1wb3J0IHsgSW5qZWN0YWJsZSwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgY2F0Y2hFcnJvciwgZmlsdGVyLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IElOR1hMb2dnZXJNZXRhZGF0YSB9IGZyb20gJy4uL21ldGFkYXRhL2ltZXRhZGF0YSc7XHJcbmltcG9ydCB7IElOR1hMb2dnZXJDb25maWcgfSBmcm9tICcuLi9jb25maWcvaWNvbmZpZyc7XHJcbmltcG9ydCB7IElOR1hMb2dnZXJTZXJ2ZXJTZXJ2aWNlIH0gZnJvbSAnLi9pc2VydmVyLnNlcnZpY2UnO1xyXG5cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgTkdYTG9nZ2VyU2VydmVyU2VydmljZSBpbXBsZW1lbnRzIElOR1hMb2dnZXJTZXJ2ZXJTZXJ2aWNlIHtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBAT3B0aW9uYWwoKSBwcm90ZWN0ZWQgcmVhZG9ubHkgaHR0cEJhY2tlbmQ6IEh0dHBCYWNrZW5kLFxyXG4gICkgeyB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybXMgYW4gZXJyb3Igb2JqZWN0IGludG8gYSByZWFkYWJsZSBzdHJpbmcgKHRha2luZyBvbmx5IHRoZSBzdGFjaylcclxuICAgKiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIEpTT04uc3RyaW5naWZ5IHdvdWxkIHJldHVybiBcInt9XCJcclxuICAgKiBAcGFyYW0gZXJyIHRoZSBlcnJvciBvYmplY3RcclxuICAgKiBAcmV0dXJucyBUaGUgc3RhY2sgb2YgdGhlIGVycm9yXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIHNlY3VyZUVycm9yT2JqZWN0KGVycjogRXJyb3IpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGVycj8uc3RhY2s7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUcmFuc2Zvcm1zIHRoZSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgdG8gYXZvaWQgYW55IGpzb24gZXJyb3Igd2hlbiBzZW5kaW5nIHRoZSBkYXRhIHRvIHRoZSBzZXJ2ZXJcclxuICAgKiBCYXNpY2FsbHkgaXQganVzdCByZXBsYWNlcyB1bnN0cmluZ2lmaWFibGUgb2JqZWN0IHRvIGEgc3RyaW5nIG1lbnRpb25pbmcgYW4gZXJyb3JcclxuICAgKiBAcGFyYW0gYWRkaXRpb25hbCBUaGUgYWRkaXRpb25hbCBkYXRhIHRvIGJlIHNlbnRcclxuICAgKiBAcmV0dXJucyBUaGUgYWRkaXRpb25hbCBkYXRhIHNlY3VyZWRcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgc2VjdXJlQWRkaXRpb25hbFBhcmFtZXRlcnMoYWRkaXRpb25hbDogYW55W10pOiBhbnlbXSB7XHJcbiAgICBpZiAoYWRkaXRpb25hbCA9PT0gbnVsbCB8fCBhZGRpdGlvbmFsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFkZGl0aW9uYWwubWFwKChuZXh0LCBpZHgpID0+IHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIEVycm9yKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZWN1cmVFcnJvck9iamVjdChuZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2UganVzdCB3YW50IHRvIG1ha2Ugc3VyZSB0aGUgSlNPTiBjYW4gYmUgcGFyc2VkLCB3ZSBkbyBub3Qgd2FudCB0byBhY3R1YWxseSBjaGFuZ2UgdGhlIHR5cGVcclxuICAgICAgICBpZiAodHlwZW9mIG5leHQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShuZXh0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBuZXh0O1xyXG4gICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIGBUaGUgYWRkaXRpb25hbFske2lkeH1dIHZhbHVlIGNvdWxkIG5vdCBiZSBwYXJzZWQgdXNpbmcgSlNPTi5zdHJpbmdpZnkoKS5gO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybXMgdGhlIG1lc3NhZ2Ugc28gdGhhdCBpdCBjYW4gYmUgc2VudCB0byB0aGUgc2VydmVyXHJcbiAgICogQHBhcmFtIG1lc3NhZ2UgdGhlIG1lc3NhZ2UgdG8gYmUgc2VudFxyXG4gICAqIEByZXR1cm5zIHRoZSBtZXNzYWdlIHNlY3VyZWRcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgc2VjdXJlTWVzc2FnZShtZXNzYWdlOiBhbnkpOiBzdHJpbmcge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNlY3VyZUVycm9yT2JqZWN0KG1lc3NhZ2UpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgbWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UsIG51bGwsIDIpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgIG1lc3NhZ2UgPSAnVGhlIHByb3ZpZGVkIFwibWVzc2FnZVwiIHZhbHVlIGNvdWxkIG5vdCBiZSBwYXJzZWQgd2l0aCBKU09OLnN0cmluZ2lmeSgpLic7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgbG9nT25TZXJ2ZXI8VD4oXHJcbiAgICB1cmw6IHN0cmluZyxcclxuICAgIGxvZ0NvbnRlbnQ6IFQsXHJcbiAgICBvcHRpb25zOiB7XHJcbiAgICAgIGhlYWRlcnM/OiBIdHRwSGVhZGVycztcclxuICAgICAgcmVwb3J0UHJvZ3Jlc3M/OiBib29sZWFuO1xyXG4gICAgICBwYXJhbXM/OiBIdHRwUGFyYW1zO1xyXG4gICAgICByZXNwb25zZVR5cGU/OiAnYXJyYXlidWZmZXInIHwgJ2Jsb2InIHwgJ2pzb24nIHwgJ3RleHQnO1xyXG4gICAgICB3aXRoQ3JlZGVudGlhbHM/OiBib29sZWFuO1xyXG4gICAgfSxcclxuICApOiBPYnNlcnZhYmxlPFQ+IHtcclxuICAgIC8vIEh0dHBCYWNrZW5kIHNraXBzIGFsbCBIdHRwSW50ZXJjZXB0b3JzXHJcbiAgICAvLyBUaGV5IG1heSBsb2cgZXJyb3JzIHVzaW5nIHRoaXMgc2VydmljZSBjYXVzaW5nIGNpcmN1bGFyIGNhbGxzXHJcbiAgICBjb25zdCByZXEgPSBuZXcgSHR0cFJlcXVlc3Q8VD4oJ1BPU1QnLCB1cmwsIGxvZ0NvbnRlbnQsIG9wdGlvbnMgfHwge30pO1xyXG5cclxuICAgIGlmICghdGhpcy5odHRwQmFja2VuZCkge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdOR1hMb2dnZXIgOiBDYW5cXCd0IGxvZyBvbiBzZXJ2ZXIgYmVjYXVzZSBIdHRwQmFja2VuZCBpcyBub3QgcHJvdmlkZWQuIFlvdSBuZWVkIHRvIGltcG9ydCBIdHRwQ2xpZW50TW9kdWxlJyk7XHJcbiAgICAgIHJldHVybiBvZihudWxsKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmh0dHBCYWNrZW5kLmhhbmRsZShyZXEpLnBpcGUoXHJcbiAgICAgIGZpbHRlcihlID0+IGUgaW5zdGFuY2VvZiBIdHRwUmVzcG9uc2UpLFxyXG4gICAgICBtYXA8SHR0cFJlc3BvbnNlPFQ+LCBUPigoaHR0cFJlc3BvbnNlOiBIdHRwUmVzcG9uc2U8VD4pID0+IGh0dHBSZXNwb25zZS5ib2R5KVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEN1c3RvbWlzZSB0aGUgZGF0YSBzZW50IHRvIHRoZSBBUElcclxuICAgKiBAcGFyYW0gbWV0YWRhdGEgdGhlIGRhdGEgcHJvdmlkZWQgYnkgTkdYTG9nZ2VyXHJcbiAgICogQHJldHVybnMgdGhlIGRhdGEgdGhhdCB3aWxsIGJlIHNlbnQgdG8gdGhlIEFQSSBpbiB0aGUgYm9keVxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBjdXN0b21pc2VSZXF1ZXN0Qm9keShtZXRhZGF0YTogSU5HWExvZ2dlck1ldGFkYXRhKTogYW55IHtcclxuICAgIC8vIEluIG91ciBBUEkgdGhlIGJvZHkgaXMgbm90IGN1c3RvbWlzZWRcclxuICAgIHJldHVybiBtZXRhZGF0YTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBzZW5kVG9TZXJ2ZXIobWV0YWRhdGE6IElOR1hMb2dnZXJNZXRhZGF0YSwgY29uZmlnOiBJTkdYTG9nZ2VyQ29uZmlnKTogdm9pZCB7XHJcbiAgICAvLyBDb3B5aW5nIG1ldGFkYXRhIGxvY2FsbHkgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGNoYW5nZSB0aGUgb2JqZWN0IGZvciB0aGUgY2FsbGVyXHJcbiAgICBjb25zdCBsb2NhbE1ldGFkYXRhID0geyAuLi5tZXRhZGF0YSB9O1xyXG5cclxuICAgIGxvY2FsTWV0YWRhdGEuYWRkaXRpb25hbCA9IHRoaXMuc2VjdXJlQWRkaXRpb25hbFBhcmFtZXRlcnMobG9jYWxNZXRhZGF0YS5hZGRpdGlvbmFsKTtcclxuXHJcbiAgICBsb2NhbE1ldGFkYXRhLm1lc3NhZ2UgPSB0aGlzLnNlY3VyZU1lc3NhZ2UobG9jYWxNZXRhZGF0YS5tZXNzYWdlKTtcclxuXHJcbiAgICAvLyBBbGxvdyB1c2VycyB0byBjdXN0b21pc2UgdGhlIGRhdGEgc2VudCB0byB0aGUgQVBJXHJcbiAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHRoaXMuY3VzdG9taXNlUmVxdWVzdEJvZHkobG9jYWxNZXRhZGF0YSk7XHJcblxyXG4gICAgY29uc3QgaGVhZGVycyA9IGNvbmZpZy5jdXN0b21IdHRwSGVhZGVycyB8fCBuZXcgSHR0cEhlYWRlcnMoKTtcclxuICAgIGlmICghaGVhZGVycy5oYXMoJ0NvbnRlbnQtVHlwZScpKSB7XHJcbiAgICAgIGhlYWRlcnMuc2V0KCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMubG9nT25TZXJ2ZXI8YW55Pihjb25maWcuc2VydmVyTG9nZ2luZ1VybCwgcmVxdWVzdEJvZHksIHtcclxuICAgICAgaGVhZGVycyxcclxuICAgICAgcGFyYW1zOiBjb25maWcuY3VzdG9tSHR0cFBhcmFtcyB8fCBuZXcgSHR0cFBhcmFtcygpLFxyXG4gICAgICByZXNwb25zZVR5cGU6IGNvbmZpZy5odHRwUmVzcG9uc2VUeXBlIHx8ICdqc29uJyxcclxuICAgICAgd2l0aENyZWRlbnRpYWxzOiBjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlLFxyXG4gICAgfSkucGlwZShjYXRjaEVycm9yKGVyciA9PiB7XHJcbiAgICAgIC8vIERvIG5vdCB1c2UgTkdYTG9nZ2VyIGhlcmUgYmVjYXVzZSB0aGlzIGNvdWxkIGNhdXNlIGFuIGluZmluaXRlIGxvb3AgXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ05HWExvZ2dlcjogRmFpbGVkIHRvIGxvZyBvbiBzZXJ2ZXInLCBlcnIpO1xyXG4gICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnIpO1xyXG4gICAgfSkpLnN1YnNjcmliZSgpO1xyXG4gIH1cclxufVxyXG4iXX0=