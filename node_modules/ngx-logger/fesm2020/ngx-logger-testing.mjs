import * as i0 from '@angular/core';
import { Injectable, NgModule } from '@angular/core';
import { NgxLoggerLevel, LoggerModule, NGXLogger, TOKEN_LOGGER_CONFIG, TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, TOKEN_LOGGER_METADATA_SERVICE, TOKEN_LOGGER_RULES_SERVICE, TOKEN_LOGGER_MAPPER_SERVICE, TOKEN_LOGGER_WRITER_SERVICE, TOKEN_LOGGER_SERVER_SERVICE, CustomNGXLoggerService } from 'ngx-logger';
import { of } from 'rxjs';

class NGXLoggerConfigEngineMock {
    get level() {
        return NgxLoggerLevel.ERROR;
    }
    get serverLogLevel() {
        return NgxLoggerLevel.OFF;
    }
    updateConfig(config) {
    }
    partialUpdateConfig(partialConfig) {
    }
    getConfig() {
        return { level: NgxLoggerLevel.ERROR };
    }
}
/** @nocollapse */ /** @nocollapse */ NGXLoggerConfigEngineMock.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerConfigEngineMock, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ /** @nocollapse */ NGXLoggerConfigEngineMock.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerConfigEngineMock });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerConfigEngineMock, decorators: [{
            type: Injectable
        }] });

// todo bmtheo, there should be an interface or something to make sure this mock sticks to the real API
class NGXLoggerMock {
    get level() {
        return NgxLoggerLevel.ERROR;
    }
    get serverLogLevel() {
        return NgxLoggerLevel.OFF;
    }
    trace(message, ...additional) {
    }
    debug(message, ...additional) {
    }
    info(message, ...additional) {
    }
    log(message, ...additional) {
    }
    warn(message, ...additional) {
    }
    error(message, ...additional) {
    }
    fatal(message, ...additional) {
    }
    partialUpdateConfig(partialConfig) {
    }
    updateConfig(config) {
    }
    setCustomHttpHeaders(headers) {
    }
    setCustomParams(params) {
    }
    registerMonitor(monitor) {
    }
    setWithCredentialsOptionValue(withCredentials) {
    }
    getConfigSnapshot() {
        return { level: NgxLoggerLevel.ERROR };
    }
}
/** @nocollapse */ /** @nocollapse */ NGXLoggerMock.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerMock, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ /** @nocollapse */ NGXLoggerMock.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerMock });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerMock, decorators: [{
            type: Injectable
        }] });

/**
 * CustomNGXLoggerServiceMock is a mock for CustomNGXLoggerService
 */
class CustomNGXLoggerServiceMock {
    create() {
        return new NGXLoggerMock();
    }
}
/** @nocollapse */ /** @nocollapse */ CustomNGXLoggerServiceMock.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: CustomNGXLoggerServiceMock, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ /** @nocollapse */ CustomNGXLoggerServiceMock.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: CustomNGXLoggerServiceMock });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: CustomNGXLoggerServiceMock, decorators: [{
            type: Injectable
        }] });

class NGXLoggerConfigEngineFactoryMock {
    provideConfigEngine(config) {
        return new NGXLoggerConfigEngineMock();
    }
}
/** @nocollapse */ /** @nocollapse */ NGXLoggerConfigEngineFactoryMock.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerConfigEngineFactoryMock, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ /** @nocollapse */ NGXLoggerConfigEngineFactoryMock.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerConfigEngineFactoryMock });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerConfigEngineFactoryMock, decorators: [{
            type: Injectable
        }] });

class NGXLoggerMapperServiceMock {
    getLogPosition(config, metadata) {
        return of({ fileName: 'test.ts' });
    }
}
/** @nocollapse */ /** @nocollapse */ NGXLoggerMapperServiceMock.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerMapperServiceMock, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ /** @nocollapse */ NGXLoggerMapperServiceMock.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerMapperServiceMock });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerMapperServiceMock, decorators: [{
            type: Injectable
        }] });

class NGXLoggerMetadataServiceMock {
    getMetadata(level, config, message, additional) {
        return {
            level: level
        };
    }
}
/** @nocollapse */ /** @nocollapse */ NGXLoggerMetadataServiceMock.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerMetadataServiceMock, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ /** @nocollapse */ NGXLoggerMetadataServiceMock.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerMetadataServiceMock });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerMetadataServiceMock, decorators: [{
            type: Injectable
        }] });

class NGXLoggerRulesServiceMock {
    shouldCallWriter(level, config, message, additional) {
        return false;
    }
    shouldCallServer(level, config, message, additional) {
        return false;
    }
    shouldCallMonitor(level, config, message, additional) {
        return false;
    }
}
/** @nocollapse */ /** @nocollapse */ NGXLoggerRulesServiceMock.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerRulesServiceMock, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ /** @nocollapse */ NGXLoggerRulesServiceMock.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerRulesServiceMock });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerRulesServiceMock, decorators: [{
            type: Injectable
        }] });

class NGXLoggerServerServiceMock {
    sendToServer(metadata, config) {
    }
    flushQueue(config) {
    }
}
/** @nocollapse */ /** @nocollapse */ NGXLoggerServerServiceMock.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerServerServiceMock, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ /** @nocollapse */ NGXLoggerServerServiceMock.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerServerServiceMock });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerServerServiceMock, decorators: [{
            type: Injectable
        }] });

class NGXLoggerWriterServiceMock {
    writeMessage(metadata, config) {
    }
}
/** @nocollapse */ /** @nocollapse */ NGXLoggerWriterServiceMock.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerWriterServiceMock, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ /** @nocollapse */ NGXLoggerWriterServiceMock.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerWriterServiceMock });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: NGXLoggerWriterServiceMock, decorators: [{
            type: Injectable
        }] });

class LoggerTestingModule {
}
/** @nocollapse */ /** @nocollapse */ LoggerTestingModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: LoggerTestingModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
/** @nocollapse */ /** @nocollapse */ LoggerTestingModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: LoggerTestingModule, imports: [LoggerModule] });
/** @nocollapse */ /** @nocollapse */ LoggerTestingModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: LoggerTestingModule, providers: [
        { provide: NGXLogger, useClass: NGXLoggerMock },
        { provide: TOKEN_LOGGER_CONFIG, useValue: { level: NgxLoggerLevel.ERROR } },
        { provide: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, useClass: NGXLoggerConfigEngineFactoryMock },
        { provide: TOKEN_LOGGER_METADATA_SERVICE, useClass: NGXLoggerMetadataServiceMock },
        { provide: TOKEN_LOGGER_RULES_SERVICE, useClass: NGXLoggerRulesServiceMock },
        { provide: TOKEN_LOGGER_MAPPER_SERVICE, useClass: NGXLoggerMapperServiceMock },
        { provide: TOKEN_LOGGER_WRITER_SERVICE, useClass: NGXLoggerWriterServiceMock },
        { provide: TOKEN_LOGGER_SERVER_SERVICE, useClass: NGXLoggerServerServiceMock },
        { provide: CustomNGXLoggerService, useClass: CustomNGXLoggerServiceMock },
    ], imports: [[LoggerModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.0.2", ngImport: i0, type: LoggerTestingModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [LoggerModule],
                    providers: [
                        { provide: NGXLogger, useClass: NGXLoggerMock },
                        { provide: TOKEN_LOGGER_CONFIG, useValue: { level: NgxLoggerLevel.ERROR } },
                        { provide: TOKEN_LOGGER_CONFIG_ENGINE_FACTORY, useClass: NGXLoggerConfigEngineFactoryMock },
                        { provide: TOKEN_LOGGER_METADATA_SERVICE, useClass: NGXLoggerMetadataServiceMock },
                        { provide: TOKEN_LOGGER_RULES_SERVICE, useClass: NGXLoggerRulesServiceMock },
                        { provide: TOKEN_LOGGER_MAPPER_SERVICE, useClass: NGXLoggerMapperServiceMock },
                        { provide: TOKEN_LOGGER_WRITER_SERVICE, useClass: NGXLoggerWriterServiceMock },
                        { provide: TOKEN_LOGGER_SERVER_SERVICE, useClass: NGXLoggerServerServiceMock },
                        { provide: CustomNGXLoggerService, useClass: CustomNGXLoggerServiceMock },
                    ]
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { CustomNGXLoggerServiceMock, LoggerTestingModule, NGXLoggerConfigEngineFactoryMock, NGXLoggerConfigEngineMock, NGXLoggerMapperServiceMock, NGXLoggerMetadataServiceMock, NGXLoggerMock, NGXLoggerRulesServiceMock, NGXLoggerServerServiceMock, NGXLoggerWriterServiceMock };
//# sourceMappingURL=ngx-logger-testing.mjs.map
